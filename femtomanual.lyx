#LyX 1.6.3 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass extbook
\begin_preamble
\usepackage{color}
\usepackage[procnames]{listings}
\usepackage{textcomp}
\usepackage{setspace}
\usepackage{palatino}
\usepackage{geometry}

\theoremstyle{plain}
\newtheorem{ex}{Exercício}[chapter]

\renewcommand{\lstlistlistingname}{Code Listings}
\renewcommand{\lstlistingname}{Code Listing}
\definecolor{gray}{gray}{0.5}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{lightgreen}{rgb}{0,0.7,0}
\definecolor{purple}{rgb}{0.5,0,0.5}
\definecolor{darkred}{rgb}{0.5,0,0}
\definecolor{orange}{rgb}{1,0.5,0}
\lstnewenvironment{python}[1][]{
\lstset{
language=python,
basicstyle=\ttfamily\small\setstretch{1},
stringstyle=\color{green},
showstringspaces=false,
alsoletter={1234567890},
otherkeywords={\ , \}, \{},
keywordstyle=\color{blue},
emph={access,and,as,break,class,continue,def,del,elif,else,%
except,exec,finally,for,from,global,if,import,in,is,%
lambda,not,or,pass,print,raise,return,try,while,assert},
emphstyle=\color{orange}\bfseries,
emph={[2]self},
emphstyle=[2]\color{gray},
emph={[4]ArithmeticError,AssertionError,AttributeError,BaseException,%
DeprecationWarning,EOFError,Ellipsis,EnvironmentError,Exception,%
False,FloatingPointError,FutureWarning,GeneratorExit,IOError,%
ImportError,ImportWarning,IndentationError,IndexError,KeyError,%
KeyboardInterrupt,LookupError,MemoryError,NameError,None,%
NotImplemented,NotImplementedError,OSError,OverflowError,%
PendingDeprecationWarning,ReferenceError,RuntimeError,RuntimeWarning,%
StandardError,StopIteration,SyntaxError,SyntaxWarning,SystemError,%
SystemExit,TabError,True,TypeError,UnboundLocalError,UnicodeDecodeError,%
UnicodeEncodeError,UnicodeError,UnicodeTranslateError,UnicodeWarning,%
UserWarning,ValueError,Warning,ZeroDivisionError,abs,all,any,apply,%
basestring,bool,buffer,callable,chr,classmethod,cmp,coerce,compile,%
complex,copyright,credits,delattr,dict,dir,divmod,enumerate,eval,%
execfile,exit,file,filter,float,frozenset,getattr,globals,hasattr,%
hash,help,hex,id,input,int,intern,isinstance,issubclass,iter,len,%
license,list,locals,long,map,max,min,object,oct,open,ord,pow,property,%
quit,range,raw_input,reduce,reload,repr,reversed,round,set,setattr,%
slice,sorted,staticmethod,str,sum,super,tuple,type,unichr,unicode,%
vars,xrange,zip},
emphstyle=[4]\color{purple}\bfseries,
upquote=true,
morecomment=[s][\color{lightgreen}]{"""}{"""},
commentstyle=\color{red}\slshape,
literate={>>>}{\textbf{\textcolor{darkred}{>{>}>}}}3%
         {...}{{\textcolor{gray}{...}}}3,
procnamekeys={def,class},
procnamestyle=\color{blue}\textbf,
framexleftmargin=1mm, framextopmargin=1mm, frame=lines,
rulesepcolor=\color{blue},#1
}}{}
\end_preamble
\options procnames
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\language portuguese
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Manual de Python"
\pdf_author "Tiago Fonseca, Francisco Silva"
\pdf_subject "Python"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3cm
\rightmargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\bullet 1 0 9 -1
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Manual de Python
\end_layout

\begin_layout Author
Francisco Silva 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 João Gomes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Miguel Zilhão 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Tiago Dinis
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introdução
\end_layout

\begin_layout Standard
Este manual foi escrito com o intuito de apoiar os projectos por nós dirigidos
 na Escola de Verão de Física, visto que estes passam por aprender o básico
 sobre Python - uma linguagem de programação simples e fácil de aprender.
 
\end_layout

\begin_layout Standard
Mas, porquê escrever mais um manual de Python? É verdade que na internet
 se encontram vários manuais de Python, no entanto estes manuais ora estão
 em inglês ora são demasiado avançados ora estão centrados em aspectos que
 não nos interessam...
 Por isso decidimos escrever um pequeno manual onde explicamos aquilo que
 necessitamos e da forma que nós queremos.
 No fim da escola este manual será actualizado e os alunos poderão utilizá-lo
 como referência caso queiram brincar um pouco mais com o Python.
 
\end_layout

\begin_layout Section
O que é simulação
\end_layout

\begin_layout Standard
Suponhamos que estamos interessados em construir um carro que seja seguro.
 Precisamos de testar o comportamento do carro em vários tipos de acidentes.
 O modo mais directo de testar a sua segurança seria realizar uma colisão
 real, ou seja, metemo-nos no carro aceleramos e chocamos contra um obstáculo.
 Este método é incómodo pois só podemos fazer a experiência uma vez e nem
 podemos analisar os resultados.
\end_layout

\begin_layout Standard
E se no lugar de pessoas usássemos bonecos, os quais simulariam o condutor
 e os passageiros? É certamente melhor para a nosssa integridade, e é uma
 das técnicas que usam os fabricantes de automóveis.
 
\end_layout

\begin_layout Standard
Mesmo assim temos um problema: para cada simulação precisamos dum carro,
 o que fica extremamente caro.
 Outra opção seria simular a situação dentro dum computador, poupando carros
 e bonecos.
 A estratégia passa por calcular todas as forças, velocidades e posições
 do carro e dos passageiros ao longo do acidente usando um computador, estimando
 no fim o dano causado nos vários passageiros.
 Podemos assim simular acidentes de forma muito mais barata e rápida e em
 inúmeras situações.
 
\end_layout

\begin_layout Standard
Claro que a simulação computacional é, em geral, menos fidedigna que o embate
 dum carro num obstáculo.
 Por isso usa-se as duas técnicas complementarmente: começa-se por simular
 no computador e numa fase mais avançada usa-se um protótipo.
\end_layout

\begin_layout Standard
Note-se que há imensas situações as quais só se podem estudar por simulação
 computacional: por exemplo a simulação da origem do universo ou nano-engrenagem
\begin_inset Foot
status open

\begin_layout Plain Layout
Podem ver no sítio 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://static.howstuffworks.com/flash/nanotechnology.swf
\end_layout

\end_inset

 uma animação de uma engrenagem nanoscópica, composta por poucos átomos.
\end_layout

\end_inset

, até agora impossíveis de fabricar.
\end_layout

\begin_layout Section
Linguagens de programação
\end_layout

\begin_layout Standard
Claro que para dar as ordens ao computador precisamos de saber comunicar
 com ele, numa linguagem que ele compreenda.
 Desde os primóridos da informática (>1940s) que se tem vindo a criar inúmeras
 destas linguagens, chamadas linguagens de programação, cada uma com o seu
 propósito e sua estrutura.
 Dado isto, a escolha de uma linguagem de programação para uma dada tarefa
 não deve ser aleatória - imaginem que têm à vossa disposição um martelo
 e uma chave de fendas - é possível colocar um parafuso à martelada, mas
 é muito mais fácil com a chave.
 
\end_layout

\begin_layout Standard
Neste manual não vamos falar de várias linguagens, nem dos seus propósitos
 ou as diferenças entre elas - embora fosse interessante.
 Para os mais curiosos, recomendamos:
\end_layout

\begin_layout Itemize
Introdução às Famílias de Linguagens de Programação: Primeiro capítulo do
 livro 
\emph on
Modern Programming Languages: A Practical Introduction
\emph default
 (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.fbeedle.com/mpl/76-7-02.pdf
\end_layout

\end_inset

);
\end_layout

\begin_layout Itemize
Uma lista e tabela de comparação do propósito usual de várias linguagens
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/Comparison_of_programming_languages
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
Estatísticas sobre a popularidade de cada linguagem no mundo: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://langpop.com/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
No nosso caso optamos por uma linguagem chamada Python.
\end_layout

\begin_layout Section
Porquê Python
\end_layout

\begin_layout Standard
Vejamos os nossos requerimentos para as nossas simulações:
\end_layout

\begin_layout Itemize
Necessitamos de uma linguagem que nos permita fazer cálculos e manipular
 os resultados facilmente;
\end_layout

\begin_layout Itemize
Esta deve permitir-nos expôr os resultados de forma conveniente - numéros,
 gráficos, animações, etc;
\end_layout

\begin_layout Itemize
Deve ser de acesso fácil e gratuito e funcione em qualquer computador ou
 sistema operativo;
\end_layout

\begin_layout Itemize
Necessitamos de uma linguagem com uma sintaxe simples cujos elementos básicos
 possam ser ensinados em menos de 1 dia.
\end_layout

\begin_layout Standard
Embora existam várias linguagens que de certo modo preencham os 4 requerimentos,
 existe uma que achamos especialmente adequada: Python.
 Esta distingue-se especialmente por ter uma sintaxe clara e ter elementos
 básicos simples.
 Esta tem ainda a vantagem de possuir vastas bibliotecas, igualmente simples
 de usar, que nos permitem fazer gráficos, animações e interagir com o utilizado
r.
\end_layout

\begin_layout Standard
Dado isto, passemos à acção.
 
\end_layout

\begin_layout Chapter
Rudimentos de Python
\end_layout

\begin_layout Standard
Neste capítulo vamos aprender a usar o básico do Python, com ele o aluno
 será capaz de fazer vários programas, simples mas poderosos.
 Supomos que o aluno usa Linux, as diferenças para outros sistemas operativos
 (Windows, MacOSX...) não são significativas.
\end_layout

\begin_layout Section
Interpretador e Operações Básicas
\end_layout

\begin_layout Standard
O método mais simples de trabalhar com Python é através do interpretador.
 Este pode ser usado por vários caminhos: na linha de comandos, pela internet
 (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://try-python.mired.org/
\end_layout

\end_inset

,
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://codepad.org
\end_layout

\end_inset

), ou até dentro doutros programas.
 Na Escola de Física será usado na linha de comandos.
 Para abrir o interpretador, introduz-se 
\emph on
python
\emph default
 na linha de comandos.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename consola.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O conceito do interpretador é simples, dá-se uma ordem e ele executa-a.
 Para sair do interpretador escreve-se 
\emph on
exit()
\emph default
 ou prime-se Control-d.
 
\end_layout

\begin_layout Standard
Comecemos por usar o interpretador como uma calculadora.
 Temos as operações elementares da álgebra:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Operação
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Símbolo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adição
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Subtracção
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiplicação
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Divisão
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exponenciação
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
**
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Calcule 
\begin_inset Formula $4.5\times3.14+3.4^{2.1}$
\end_inset

.
 Reparem que o Python usa um ponto como separador décimal.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Quanto vale 
\begin_inset Formula $3/2$
\end_inset

? E 
\begin_inset Formula $3.01/2$
\end_inset

?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Quanto falta a 
\begin_inset Formula $2354785$
\end_inset

 para ser um múltiplo de 
\begin_inset Formula $7$
\end_inset

?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Variáveis
\end_layout

\begin_layout Subsection
Variáveis numéricas
\end_layout

\begin_layout Standard
Em Python existem três tipos principais de variáveis numéricas:
\end_layout

\begin_layout Itemize
Os números inteiros, por exemplo 
\begin_inset Formula $n=3$
\end_inset

;
\end_layout

\begin_layout Itemize
Os números reais, por exemplo 
\begin_inset Formula $x=-3.14$
\end_inset

;
\end_layout

\begin_layout Itemize
E os números complexos, como por exemplo 
\begin_inset Formula $z=3.2+1j$
\end_inset

.
 Notem que o Python usa 
\begin_inset Formula $j$
\end_inset

, e não 
\begin_inset Formula $i$
\end_inset

 como é habitual.
\end_layout

\begin_layout Standard
Caso não haja separador décimal o Python assume que o número é inteiro.
 Isto pode trazer problemas nas divisões, por exemplo 
\begin_inset Formula $1/2=0$
\end_inset

, mas 
\begin_inset Formula $1./2.=0.5$
\end_inset

.
\end_layout

\begin_layout Standard
Quando se escreve 
\begin_inset Formula $n=3$
\end_inset

 está-se a guardar o valor 
\begin_inset Formula $3$
\end_inset

 em 
\begin_inset Formula $n$
\end_inset

.
 Vejamos o exemplo seguinte:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename atribuir.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O que acontece: 
\end_layout

\begin_layout Enumerate
Na primeira linha guardamos o valor 
\begin_inset Formula $3$
\end_inset

 na variável 
\begin_inset Formula $n$
\end_inset

;
\end_layout

\begin_layout Enumerate
Na segunda guardamos o valor 
\begin_inset Formula $5$
\end_inset

 em 
\begin_inset Formula $m$
\end_inset

;
\end_layout

\begin_layout Enumerate
Na terceira linha estamos a copiar o valor da variável 
\begin_inset Formula $n$
\end_inset

 (que neste caso é 
\begin_inset Formula $3$
\end_inset

) para a variável 
\begin_inset Formula $m$
\end_inset

;
\end_layout

\begin_layout Enumerate
Por fim perguntamos o valor de 
\begin_inset Formula $m$
\end_inset

 ao computador.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Se num quinto passo atribuirmos o valor 
\begin_inset Formula $7$
\end_inset

 a 
\begin_inset Formula $n$
\end_inset

, quanto vale agora 
\begin_inset Formula $m$
\end_inset

?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cadeias de caracteres
\end_layout

\begin_layout Standard
Mas nem todas as variáveis são números, podemos também definir cadeias de
 caracteres.
 As cadeias de caracteres são delimitadas por 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes erd
\end_inset

 ou por 
\begin_inset Quotes els
\end_inset

 
\begin_inset Quotes ers
\end_inset

, vejamos um exemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename string.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Infelizmente, nem todos os caracteres se podem usar em cadeias de caracteres,
 por vezes é preciso usar certos atalhos, por exemplo uma nova linha escreve-se
 
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

, as aspas 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset

...
\end_layout

\begin_layout Standard
As cadeias de caracteres são estruturas rígidas, ou seja, não se podem alterar.
 Mas em contrapartida pode-se aceder a apenas parte da cadeia:
\end_layout

\begin_layout Itemize
a[i] acede ao i-ésimo caracter, por exemplo a[4] é igual a 
\begin_inset Quotes eld
\end_inset

v
\begin_inset Quotes erd
\end_inset

.
 Note-se que a numeração dos caracteres começa pelo 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Itemize
a[:j] acede a todos os caracteres até à posição j, j não incluído, por exemplo
 a[:8] é igual 
\begin_inset Quotes eld
\end_inset

As aves 
\begin_inset Quotes eld
\end_inset

.
\end_layout

\begin_layout Itemize
a[i:] é igual ao anterior mas acedendo a todos os números após i, i incluído.
\end_layout

\begin_layout Itemize
a[i:j] acede aos caracteres entre as posições i e j, por exemplo a[3:6]
 é igual a 
\begin_inset Quotes eld
\end_inset

ave
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Pode-se também juntar várias cadeias, usando um sinal de +, por exemplo
 
\begin_inset Quotes eld
\end_inset

Eu tenho uma
\begin_inset Quotes erd
\end_inset

+
\begin_inset Quotes eld
\end_inset

 mesa
\begin_inset Quotes erd
\end_inset

 é igual a 
\begin_inset Quotes eld
\end_inset

Eu tenho uma mesa
\begin_inset Quotes erd
\end_inset

.
 Ou multiplicar uma cadeia por um número natural: 2*
\begin_inset Quotes erd
\end_inset

po
\begin_inset Quotes erd
\end_inset

 é igual a 
\begin_inset Quotes eld
\end_inset

popo
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Crie uma variável com o valor 
\begin_inset Quotes eld
\end_inset

Das uvas se faz o vinho!
\begin_inset Quotes erd
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Modifique a variável para 
\begin_inset Quotes eld
\end_inset

Das macas se faz a cidra!
\begin_inset Quotes erd
\end_inset

.
 É possível pôr cedilhas e acentos nas palavras, mas nós vamos evitá-los.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Listas
\end_layout

\begin_layout Standard
Uma lista é um conjunto ordenado de objectos, estes podem ser números, cadeias
 de caracteres ou mesmo outras listas.
 Em Python uma lista é delimitada por parentesis rectos, por exemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename lista.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como podem ver as listas são mais flexiveis que as cadeias.
 Vejamos algumas das operações que podemos realizar com elas:
\end_layout

\begin_layout Itemize
A.append(X) acrescenta o elemento X ao fim da lista A;
\end_layout

\begin_layout Itemize
A.insert(I,X) acrescenta o elemento X na posição I da lista A;
\end_layout

\begin_layout Itemize
A.extend(B) une a lista A com a lista B.
 Com a B após a A;
\end_layout

\begin_layout Itemize
A.index(X) devolve a posição da primeira aparição do elemento X na lista
 A;
\end_layout

\begin_layout Itemize
A.remove(X) apaga o primeiro elemento X da lista A;
\end_layout

\begin_layout Itemize
len(A) calcula o comprimento da lista A, ou seja, o número de elementos
 que a lista A contém;
\end_layout

\begin_layout Itemize
A+B devolve a união das listas A e B;
\end_layout

\begin_layout Itemize
n*A devolve a lista A repetida n vezes.
\end_layout

\begin_layout Standard
Vejamos um exemplo:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename lista_op.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Crie duas listas, digamos A e B, e calcule A.append(B), o que é que acontece?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Crie uma lista com todos os números inteiros ordenados entre 1 e 50.
 Dica experimente o que acontece se fizer range(10).
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Ficheiros Python
\end_layout

\begin_layout Standard
Imaginem que estamos a fazer um cálculo e ao final de 30 min reparamos que
 nos enganamos.
 Ora temos que repetir quase tudo.
 Mas existe uma solução que é escrever num ficheiro as ordens, a que nós
 chamamos normalmente de código, que nós queremos que o computador siga.
\end_layout

\begin_layout Standard
Por isso, começamos por abrir um editor de texto qualquer, e escrevemos:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frase="Este é o meu primeiro programa!" #Isto é um comentário
\end_layout

\begin_layout Plain Layout

print frase
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gravamos o ficheiro, por exemplo com o nome primeiro.py (o .py serve para
 identificar os ficheiros de Python), e por fim corremos o Python com o
 ficheiro usando o comando 
\emph on
python primeiro.py
\emph default
.
\end_layout

\begin_layout Standard
Vamos analisar o programa:
\end_layout

\begin_layout Itemize
#coding=utf8 permite usar caracteres acentuados e o ç;
\end_layout

\begin_layout Itemize
frase=
\begin_inset Quotes erd
\end_inset

Este é o meu primeiro programa.
\begin_inset Quotes erd
\end_inset

 cria uma cadeia de caracteres;
\end_layout

\begin_layout Itemize
# indica um comentário, o Python ignora a partir deste símbolo até à mudança
 de linha;
\end_layout

\begin_layout Itemize
print frase é o comando que escreve (ou imprime) o valor da variável frase
 na linha de comandos.
\end_layout

\begin_layout Standard
O código deve ser limpo, bem organizado e muito bem comentado.
 Senão, ninguém será capaz de perceber o que vocês estão a fazer nem mesmo
 vocês daqui a uma semana.
\end_layout

\begin_layout Standard
No caso especial do Python, o código tem que ser devidamente indentado (que
 consiste na adição de tabulações no início de cada linha), explicaremos
 este conceito à medida que precisarmos dele.
\end_layout

\begin_layout Section
Funções
\end_layout

\begin_layout Standard
Imaginemos que queremos calcular o seno de 
\begin_inset Formula $0.3$
\end_inset

, imprimir
\begin_inset Foot
status open

\begin_layout Plain Layout
Imprimir significa que o nosso programa nos devolve algo, por exemplo na
 linha de comandos, num ficheiro pdf ou em papel.
\end_layout

\end_inset

 uma frase ou colocar uma lista em ordem alfabética.
 Para efectuar estas tarefas vamos precisar de usar funções.
\end_layout

\begin_layout Subsection
Print
\end_layout

\begin_layout Standard
De nada serve fazer um programa se ele não comunicar com o utilizador.
 A função print imprime aquilo que nós quisermos para a linha de comandos,
 como viram no exemplo anterior.
 Mas podemos fazer coisas mais complicadas:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

n=5
\end_layout

\begin_layout Plain Layout

print "Este é o meu primeiro cálculo:","
\backslash
n",n,"ao quadrado é",n**2
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O resultado é simples de interpretar:
\end_layout

\begin_layout Itemize
Começamos por imprimir a frase: 
\begin_inset Quotes eld
\end_inset

Este é o meu primeiro cálculo:
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Itemize
Criamos uma nova linha com o 
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Itemize
Imprimimos o valor de n, lembrem-se que n vale 5;
\end_layout

\begin_layout Itemize
Imprimimos 
\begin_inset Quotes eld
\end_inset

ao quadrado é
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Itemize
E por fim, o programa devolve o valor de 
\begin_inset Formula $n^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Outra forma de escrever este exemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

n=5
\end_layout

\begin_layout Plain Layout

print "Este é o meu primeiro cálculo:
\backslash
n %i ao quadrado é %i" % (n,n**2)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notem que utilizamos o operador 
\emph on
%i 
\emph default
para introduzir uma variável inteira.
 Para variáveis reais usa-se 
\emph on
%f 
\emph default
e para cadeias usa-se 
\emph on
%s
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Crie um ficheiro que imprima a frase 
\begin_inset Quotes eld
\end_inset

Se 
\begin_inset Formula $n=3$
\end_inset

 e 
\begin_inset Formula $m=2$
\end_inset

, então 
\begin_inset Formula $n\times m=6$
\end_inset


\begin_inset Quotes erd
\end_inset

, e onde seja fácil mudar os valores de 
\begin_inset Formula $n$
\end_inset

 e 
\begin_inset Formula $m$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Input
\end_layout

\begin_layout Standard
Vamos ser audaciosos e construir um programa que peça valores ao utilizador:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n=input("Escreve um número:")  
\end_layout

\begin_layout Plain Layout

print "O número que escreveu foi",n
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A função input imprime um texto e fica à espera que o utilizador devolva
 um número, uma lista, uma cadeia de caracteres...
 escritos como se fosse no ficheiro, ou seja, no caso duma cadeia de caracteres
 é preciso colocar as aspas.
\end_layout

\begin_layout Standard
Existe uma outra versão que é
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

s=raw_input("Como é que te chamas?") 
\end_layout

\begin_layout Plain Layout

print "O teu nome é",s
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta função faz exactamente a mesma coisa que input mas grava tudo o que
 utilizador escrever em forma de cadeia de caracteres.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Para inserir uma cadeia de caracteres não é preciso colocar aspas.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Escreve um programa que dê uma lista com todos os números inteiros entre
 dois valores definidos pelo utilizador.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Transformar cadeias de caracteres em números e vice-versa
\end_layout

\begin_layout Standard
Para o Python 
\begin_inset Quotes eld
\end_inset

45
\begin_inset Quotes erd
\end_inset

 e 45 são coisas diferentes, sendo, respectivamente, uma cadeia de caracteres
 e um número.
 Mas podemos convertê-los facilmente:
\end_layout

\begin_layout Itemize
A função str() transforma um número ou uma lista numa cadeia de caracteres;
\end_layout

\begin_layout Itemize
Enquanto que a função eval() faz a transformação inversa.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Explique, passo por passo, o que acontece ao escrevermos:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

a=56
\end_layout

\begin_layout Plain Layout

b=str(a)
\end_layout

\begin_layout Plain Layout

c=2*b
\end_layout

\begin_layout Plain Layout

d=eval(c)
\end_layout

\begin_layout Plain Layout

print 2*d
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Definir funções
\end_layout

\begin_layout Standard
Por vezes queremos usar funções que ainda não estão definidas, nesse caso
 temos que ser nós a defini-las.
 Vejamos um exemplo duma definição:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

def soma(x,y):
\end_layout

\begin_layout Plain Layout

  u=x+y
\end_layout

\begin_layout Plain Layout

  return 2*u
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g=3
\end_layout

\begin_layout Plain Layout

h=2
\end_layout

\begin_layout Plain Layout

print soma(g,h)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Neste exemplo existem vários promenores importantes:
\end_layout

\begin_layout Itemize
Uma função precisa dum nome, por exemplo, 
\begin_inset Quotes eld
\end_inset

soma
\begin_inset Quotes erd
\end_inset

, os nomes devem ser simples e explícitos;
\end_layout

\begin_layout Itemize
Para definir uma função usa-se 
\begin_inset Quotes eld
\end_inset

def função(variáveis):
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Itemize
Pode haver quantas variáveis nós queiramos, de notar que os nomes que usamos
 aqui só servem para a definição;
\end_layout

\begin_layout Itemize
O Python é uma linguagem de identação, ou seja, ele sabe que determinadas
 ordens pertencem à função porque estão identadas;
\end_layout

\begin_layout Itemize
Dentro da função podemos fazer o que quisermos;
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

return
\begin_inset Quotes erd
\end_inset

 devolve-nos o resultado da função, note-se que não é obrigatório haver
 um resultado, a função pode imprimir algo na linha de comandos;
\end_layout

\begin_layout Itemize
A função acaba quando o texto deixar de ser identado.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Escreva um programa que calcule 
\begin_inset Formula $n^{2}$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Escreva um programa que nos devolva 
\begin_inset Formula $n!$
\end_inset

.
 Use o facto de se 
\begin_inset Formula $n=1$
\end_inset

, 
\begin_inset Formula $n!=1$
\end_inset

, escrito na linha: 
\begin_inset Quotes eld
\end_inset

If n==1: return 1
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Se n for igual a 1 devolve 1.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Controlo de fluxo
\end_layout

\begin_layout Standard
Às vezes queremos que uma certa ordem seja realizada apenas se uma certa
 condição é respeitada ou então queremos repetir uma acção umas tantas vezes.
 A isso chamamos de controlo de fluxo.
\end_layout

\begin_layout Subsection
Condições
\end_layout

\begin_layout Standard
Em linguagem corrente uma condição exprime-se 
\begin_inset Quotes eld
\end_inset

Se chover eu não sairei de casa.
\begin_inset Quotes erd
\end_inset

, ora em inglês 
\begin_inset Quotes eld
\end_inset

se
\begin_inset Quotes erd
\end_inset

 escreve-se 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

, vejamos um exemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

n=input("Escreva um número: ")
\end_layout

\begin_layout Plain Layout

if n==0:
\end_layout

\begin_layout Plain Layout

  print "O número é nem positivo nem negativo"
\end_layout

\begin_layout Plain Layout

  print "Ou seja, é o zero."
\end_layout

\begin_layout Plain Layout

elif n>0:
\end_layout

\begin_layout Plain Layout

  print "O número é positivo"
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

  print "O número é negativo"
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Existe três comandos a ter em conta:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

If
\begin_inset Quotes erd
\end_inset

 que significa 
\begin_inset Quotes eld
\end_inset

se
\begin_inset Quotes erd
\end_inset

, neste caso 
\begin_inset Quotes eld
\end_inset

se n=0
\begin_inset Quotes erd
\end_inset

 ele cumpre as ordens que aparecem em baixo identadas;
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

elif
\begin_inset Quotes erd
\end_inset

 significa 
\begin_inset Quotes eld
\end_inset

senão se
\begin_inset Quotes erd
\end_inset

, ou seja, se as condições que a precedem não forem respeitadas ela aplica
 mais uma condição;
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

else
\begin_inset Quotes erd
\end_inset

 significa 
\begin_inset Quotes eld
\end_inset

senão
\begin_inset Quotes erd
\end_inset

 e significa que se nenhuma das condições anteriores for respeitada ela
 cumpre as ordens que aparecem identadas em baixo.
\end_layout

\begin_layout Standard
As condições podem ser escritas usando os símbolos apresentados na tabela:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
símbolo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
significado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $==$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
igual
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
diferente
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
maior
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $<$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
menor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
maior ou igual
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $<=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
menor ou igual
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podemos ainda combinar várias condições usando 
\begin_inset Quotes eld
\end_inset

and
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

not
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Em português 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ou
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

não
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

, por exemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

n=input("Escreva um número: ")
\end_layout

\begin_layout Plain Layout

m=input("E um segundo número: ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if n>0 and m>0:
\end_layout

\begin_layout Plain Layout

  print "São ambos positivos."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (n>0 or m>0) and not (n>0 and m>0):
\end_layout

\begin_layout Plain Layout

  print "Um e só um é positivo."
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No primeiro exemplo temos que 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $n>0$
\end_inset

 e 
\begin_inset Formula $m>0$
\end_inset


\begin_inset Quotes erd
\end_inset

, enquanto que o segundo exemplo lê-se 
\begin_inset Quotes eld
\end_inset

um ou outro
\begin_inset Quotes erd
\end_inset

 e não 
\begin_inset Quotes eld
\end_inset

um e outro
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Crie um programa que verifique se certo número é par ou impar.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Dado um determinado par de números queremos que um e apenas um seja positivo.
 Já damos um exemplo de como fazer isso, dê outros exemplos.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Repetições: para ...
 em ...
\end_layout

\begin_layout Standard
Temos uma operação e queremo-la repetir mil vezes.
 Ou escrevemos a ordem mil vezes, ou usamos um ciclo for (para em inglês):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

n=input("Até que limite? ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for i in range(n):
\end_layout

\begin_layout Plain Layout

  print 2*i
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este programa imprime o dobro de todos os inteiros entre 0 e n-1.
 Vejamos passo por passo:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

for i in range(n)
\begin_inset Quotes erd
\end_inset

, significa que para todo o elemento, ao qual damos o nome de 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

, que está na lista 
\begin_inset Quotes eld
\end_inset

range(n)
\begin_inset Quotes erd
\end_inset

 efectuamos as ordens seguintes;
\end_layout

\begin_layout Itemize
As ordens aparecem nas linhas em baixo e aparecem identadas, neste caso
 imprimimos o dobro de cada elemento.
\end_layout

\begin_layout Standard
Por vezes, queremos parar um ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 abruptamente, para isso usamos o comando 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

n=input("Até que número? ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for i in range(n):   
\end_layout

\begin_layout Plain Layout

  print 2*i   
\end_layout

\begin_layout Plain Layout

  if i>=100:     
\end_layout

\begin_layout Plain Layout

    print "Atingiu o limite"     
\end_layout

\begin_layout Plain Layout

    break
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note que:
\end_layout

\begin_layout Itemize
As operações dentro do ciclo 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

 estão identadas em relação ao 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Itemize
O 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

 quebra o ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 imediatamente antes do 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Crie uma lista de naipes (paus, ouros, copas e espadas) e uma lista de valores
 de cartas (Ás, 2, 3, 4, 5, 6, 7, Valete, Dama e Rei) e imprima todas as
 cartas do baralho português.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Verifique se determinado número é primo.
 Use a função 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Faça um programa que gere uma lista de números primos.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Repetições: enquanto ...
\end_layout

\begin_layout Standard
Podemos também repetir uma ordem enquanto (while em inglês) algo aconteça,
 por exemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

n=0
\end_layout

\begin_layout Plain Layout

while n<=0:
\end_layout

\begin_layout Plain Layout

  n=input("Escreva um número positivo: ")
\end_layout

\begin_layout Plain Layout

print n
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O ciclo vai ser repetido enquanto 
\begin_inset Formula $n$
\end_inset

 for negativo.
\end_layout

\begin_layout Standard
Opcialmente o ciclo pode ser acompanhado por um 
\begin_inset Quotes eld
\end_inset

else
\begin_inset Quotes erd
\end_inset

 que será realizado assim que a condição deixe de ser cumprida.
 
\end_layout

\begin_layout Standard
À imagem do ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 podemos quebrar um ciclo usando o comando 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

.
 E nesse caso o 
\begin_inset Quotes eld
\end_inset

else
\begin_inset Quotes erd
\end_inset

 não vai ser realizado.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Queremos calcular a raiz quadrada de 
\begin_inset Formula $n$
\end_inset

.
 Um método rudimentar é de pedir estimativas ao utilizador até que ele se
 aproxime o suficiente.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Um outro método é usando o algorítmo: seja 
\begin_inset Formula $r$
\end_inset

 uma estimativa da raiz quadrada, sabemos que 
\begin_inset Formula $\frac{1}{2}(r+\frac{n}{r})$
\end_inset

 vai estar mais próximo da raiz.
 Calcule a raiz quadrada com uma boa precisão.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Python mais avançado
\end_layout

\begin_layout Section
Ajuda
\end_layout

\begin_layout Standard
Mesmo depois de usar Python durante anos, não é suposto saber tudo sobre
 ele.
 Para isso existem manuais, a internet e a ajuda do Python.
 É sobre a última que nos debruçaremos a seguir.
 Num interpretador de Python escreva 
\begin_inset Quotes eld
\end_inset

help(pow)
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename help.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como podem ver, o Python explica-nos como funciona a função 
\begin_inset Quotes eld
\end_inset

pow
\begin_inset Quotes erd
\end_inset

.
 Ela pega em dois ou três argumentos e devolve-nos um número.
 
\end_layout

\begin_layout Section
Bibliotecas
\end_layout

\begin_layout Standard
Experimente escrever 
\begin_inset Quotes eld
\end_inset

cos(2.1)
\begin_inset Quotes erd
\end_inset

 no interpretador.
 Em princípio o Python não reconhece a função.
 Mas o Python pode ser extendido graças a bibliotecas que contém a definição
 de algumas funções:
\end_layout

\begin_layout Itemize
A biblioteca padrão adiciona várias funcionalidades ditas padrão ao Python.
 Dentro desta biblioteca existem vários módulos:
\end_layout

\begin_deeper
\begin_layout Itemize
O módulo math onde estão definidas várias funções como o seno, a exponencial,
 o logaritmo, a raiz quadrada entre outras (ver a ajuda do math) e também
 duas constantes o 
\begin_inset Formula $\pi$
\end_inset

 e a constante de euler 
\begin_inset Formula $e$
\end_inset

.
 Veremos na secção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:mathmath"

\end_inset

 como utilizar este módulo.
 Só para números reais;
\end_layout

\begin_layout Itemize
O módulo cmath permite funcionalidade parecidas com o módulo math mas definidas
 para números complexos;
\end_layout

\begin_layout Itemize
O módulo random permite-nos usar números pseudo-aleatórios;
\end_layout

\begin_layout Itemize
O módulo time permite várias operações com o tempo;
\end_layout

\end_deeper
\begin_layout Itemize
numpy extende as potencialidades do Python, definindo vectores, matrizes
 multi-dimensionais bem como funções que operam nesses objectos.
 Existe ainda o scipy que o complementa;
\end_layout

\begin_layout Itemize
A biblioteca matplotlib que contém o módulo pylab que define várias rotinas
 para desenhar gráficos, ver secção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:pylab"

\end_inset

;
\end_layout

\begin_layout Itemize
A biblioteca VPython ou Visual Python permite-nos criar, de forma simples,
 gráficos e animações a 3d interactivos.
\end_layout

\begin_layout Standard
Para aceder a um módulo usamos o comando:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#Primeiro importamos o módulo
\end_layout

\begin_layout Plain Layout

import modulo
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Para usar uma função presente no módulo, escrevemos:
\end_layout

\begin_layout Plain Layout

modulo.funcao(x)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ou então
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#Importamos uma função presente no módulo
\end_layout

\begin_layout Plain Layout

from modulo import funcao
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Para usar essa função presente no módulo, escrevemos:
\end_layout

\begin_layout Plain Layout

funcao(x)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A primeira importa todo o módulo ao início enquanto que a segunda apenas
 importa uma função presente no módulo.
 A escolha de um dos métodos depende da nossa intenção.
 
\end_layout

\begin_layout Subsection
O módulo math
\begin_inset CommandInset label
LatexCommand label
name "sub:mathmath"

\end_inset


\end_layout

\begin_layout Standard
Um dos módulos que nós mais vamos usar é o math, dele fazem parte as seguintes
 funções
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Função 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comando
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Coseno
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cos()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Seno
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sin()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tangente
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tan()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arco-coseno
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
acos()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arco-seno
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
asin()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arco-tangente
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
atan()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exponencial
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exp()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logaritmo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
log()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Raiz Quadrada
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sqrt()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Potência (
\begin_inset Formula $x^{y}$
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pow(x,y)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Valor absoluto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fabs()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arredondamento por cima
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ceil()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arredondamento por baixo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
floor()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constante de Euler
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\pi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pi
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Duas notas.
 O seno, coseno e tangente usam radianos.
 No caso do logaritmo não nepariano usa-se log(,base)
\end_layout

\begin_layout Standard
Vamos ver alguns exemplos de utilização:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

import math
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "O coseno de pi sobre 3 é:",math.cos(math.pi/3)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ou então
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

from math import pow, pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "A raiz cúbica de pi é:",pow(pi,1./3.)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Imprima uma tabela com o coseno entre 0 e 1.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
O módulo numpy
\end_layout

\begin_layout Standard
Vamos usar o módulo numpy para criar e manipular vectores e matrizes.
 Um pequeno exemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

import numpy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria um vector tridimensional de valores reais
\end_layout

\begin_layout Plain Layout

a=numpy.array([3],Float)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Damos um valor às componentes do vector
\end_layout

\begin_layout Plain Layout

a[0]=1
\end_layout

\begin_layout Plain Layout

a[1]=3.2
\end_layout

\begin_layout Plain Layout

a[2]=0.1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria uma matriz 3x3 de valores inteiros inicializada a zero
\end_layout

\begin_layout Plain Layout

M=numpy.zeros([3,3],Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Altera o valor das entradas da matriz
\end_layout

\begin_layout Plain Layout

M[0][2]=1
\end_layout

\begin_layout Plain Layout

M[1][1]=-1
\end_layout

\begin_layout Plain Layout

M[2][0]=1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Imprime a matriz
\end_layout

\begin_layout Plain Layout

print M
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
O módulo pylab 
\begin_inset CommandInset label
LatexCommand label
name "sub:pylab"

\end_inset


\end_layout

\begin_layout Standard
O nosso próximo passo vai ser aprender a fazer gráficos.
\end_layout

\begin_layout Standard
Vejamos um exemplo de utilização:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Criamos duas listas com os valores de x e de y
\end_layout

\begin_layout Plain Layout

lista_X=[1,2,3,4,5,6,7,8,9,10]
\end_layout

\begin_layout Plain Layout

lista_Y=[1,3,7,10,5,7,2,0,-2,0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Criamos um gráfico com as duas listas
\end_layout

\begin_layout Plain Layout

pylab.plot(lista_X,lista_Y,"--g")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Damos-lhe o título de "O meu primeiro grafico!"
\end_layout

\begin_layout Plain Layout

pylab.title("O meu primeiro grafico!")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Gravamos o gráfico no ficheiro grafico.png
\end_layout

\begin_layout Plain Layout

pylab.savefig("grafico.png")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Desenhamos o gráfico no ecrã
\end_layout

\begin_layout Plain Layout

pylab.show()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O módulo pylab contém muitas funções já pré-definidas, dentro das quais
 encontramos:
\end_layout

\begin_layout Itemize
plot(X,Y,opções), desenha um gráfico com as abcissas X, as ordenadas Y.
 Nas opções podemos definir o estilo, a cor, a espessura, o nome entre outras
 propriedades da linha (ver a ajuda de pylab.plot).
 De notar que ele desenha o gráfico na memória mas não o mostra nem grava
 nenhum ficheiro.
 Podemos desenhar várias linhas.;
\end_layout

\begin_layout Itemize
show(), comando que usaremos quase sempre no fim do programa.
 Ele mostra os gráficos que nós desenhamos;
\end_layout

\begin_layout Itemize
savefig(
\begin_inset Quotes eld
\end_inset

figura
\begin_inset Quotes erd
\end_inset

), grava o ficheiro em formato png com o nome figura.png;
\end_layout

\begin_layout Itemize
title(
\begin_inset Quotes eld
\end_inset

Titulo giro
\begin_inset Quotes erd
\end_inset

), dá ao gráfico o título: 
\begin_inset Quotes eld
\end_inset

Titulo giro
\begin_inset Quotes erd
\end_inset

; 
\end_layout

\begin_layout Itemize
xlabel(
\begin_inset Quotes eld
\end_inset

x_nome
\begin_inset Quotes erd
\end_inset

), dá um nome ao eixo das abcissas;
\end_layout

\begin_layout Itemize
ylabel(
\begin_inset Quotes eld
\end_inset

y_name
\begin_inset Quotes erd
\end_inset

), o equivalente para o eixo das ordenadas;
\end_layout

\begin_layout Itemize
axis([x_min,x_max,y_min,y_max]), define o tamanho dos eixos, permite outras
 opções como 
\begin_inset Quotes eld
\end_inset

auto
\begin_inset Quotes erd
\end_inset

 que permite ao Python de escolher os intervalos;
\end_layout

\begin_layout Itemize
xlim(), o mesmo que axis() mas só para o eixo de x;
\end_layout

\begin_layout Itemize
ylim(), o mesmo que axis() mas só para o eixo de y;
\end_layout

\begin_layout Itemize
legend(), cria uma legenda.
 Atenção que o nome que aparece é definido no plot() (ou no subplot());
\end_layout

\begin_layout Itemize
subplot(), cria uma grelha de gráficos, útil para quando se quer desenhar
 vários gráficos lado a lado;
\end_layout

\begin_layout Itemize
hist(), faz um histograma;
\end_layout

\begin_layout Itemize
figure(), cria um outro gráfico.
 Útil quando se quer fazer vários gráficos, mas em janelas diferentes.
 Quando se faz show() as várias figuras vão aparecer.
 Pode ser escrito na forma fig=figure(), agora fig representa esta figura;
\end_layout

\begin_layout Itemize
close(), serve para recomeçar um gráfico.
 Pode ser usado em conjugação com o figure(), por exemplo, depois de fazer
 5 figuras (fig1, fig2, fig3, fig4 e fig5) e de as gravar todas em ficheiros,
 queremos ver todas menos a 4ª.
 Nesse caso fazemos close(fig4), e todas ficam activas excepto a 4ª.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Desenhe o gráfico do seno de 0 a 
\begin_inset Formula $\pi$
\end_inset

.
 Faça com 5, 100 e 1000 pontos.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Embeleze o gráfico com título, legenda, cores...
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Visual Python
\end_layout

\begin_layout Standard
Vejamos agora um exemplo simples da utilização do Visual Python:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

from visual import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria uma caixa na posição (0,0,0) de comprimento 4, altura 0.5 e espessura
 4 de cor azul
\end_layout

\begin_layout Plain Layout

caixa = box(pos=(0,0,0), length=4, height=0.5, width=4, color=color.blue)
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria uma esfera na posição (0,4,0) de raio 1 e de cor vermelha
\end_layout

\begin_layout Plain Layout

bola = sphere(pos=(0,4,0), radius=1, color=color.red) 
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O resultado pode ser visto na seguinte figura:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename visual.png
	lyxscale 40
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
É possível rodar a figura mantendo o botão direito do rato premido sobre
 a janela e movendo-o.
 Procedendo da mesma maneira com o botão do meio permite-nos ampliar ou
 reduzir.
\end_layout

\begin_layout Standard
Para além de caixas e bolas é possível desenhar outros objectos:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Objecto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comando
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Algumas opções
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Caixa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
box
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,length=<x>,height=<x>,width=<x>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cilindro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cylinder
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,axis=<v>,radius=<x>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Esfera
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sphere
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,radius=<x>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cone
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cone
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,axis=<v>,radius=<x>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pirâmide
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pyramid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,size=<v>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Seta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
arrow
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,axis=<v>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Elipsoide
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ellipsoid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,length=<x>,height=<x>,width=<n>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Curva
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
curve
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=[<p
\begin_inset Formula $_{1}$
\end_inset

>,<p
\begin_inset Formula $_{2}$
\end_inset

>
\begin_inset Formula $\ldots$
\end_inset

],radius=<x>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ring
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,axis=<v>,radius=<x>,thickness=<x>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hélice
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
helix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,axis=<v>,radius=<x>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Etiqueta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
label
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pos=<p>,text=
\begin_inset Quotes erd
\end_inset

Texto
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Em que <p> é um ponto, por exempo 
\begin_inset Formula $(1,1,1)$
\end_inset

, <v> é um vector, por exemplo 
\begin_inset Formula $(2,0,-1)$
\end_inset

, e <x> é um número real.
\end_layout

\begin_layout Standard
Com o Visual Python podemos animar facilmente objectos, basta para isso
 alterar as propriedades dos objectos num ciclo.
 Vejamos uma bola a orbitar em torno dum cilindro:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

from visual import *
\end_layout

\begin_layout Plain Layout

from math import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N=1000   #Número de iterações
\end_layout

\begin_layout Plain Layout

x=sin(0) #Posição inicial
\end_layout

\begin_layout Plain Layout

y=cos(0) #Posição inicial
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Definimos um cilindro e uma esfera
\end_layout

\begin_layout Plain Layout

eixo=cylinder(pos=(0,0,-1),axis=(0,0,2),radius=0.2)
\end_layout

\begin_layout Plain Layout

bola=sphere(pos=(x,y,0),radius=0.3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Actualizamos a posição da esfera
\end_layout

\begin_layout Plain Layout

for i in range(N):
\end_layout

\begin_layout Plain Layout

  rate(100) #Limita o número de actualizações por segundo a 100
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  x=sin(i*2*pi/N)
\end_layout

\begin_layout Plain Layout

  y=cos(i*2*pi/N)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # Actualiza a posição da bola
\end_layout

\begin_layout Plain Layout

  bola.pos=(x,y,0)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podem encontrar no site 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://vpython.org/contents/doc.html
\end_layout

\end_inset

 informações mais detalhadas sobre o Visual Python.
 Um bom tutorial será 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://vpython.org/contents/docs/visual/VPython_Intro.pdf
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Anime uma bola, fazendo-a aumentar e diminuir de volume sinusoidalmente.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Trabalhar com ficheiros
\end_layout

\begin_layout Standard
Frequentemente, necessitamos de guardar os resultados dos nossos programas
 em ficheiros de texto.
 Ou então ir buscar dados a um ficheiro...
 Para abrir um ficheiro (quer ele exista ou não) usa-se o comando:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Abrimos um ficheiro chamado dados.txt
\end_layout

\begin_layout Plain Layout

fic=open("dados.txt","w")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Escrevemos uma frase no ficheiro
\end_layout

\begin_layout Plain Layout

fic.write("Galileu Galilei morreu no ano:
\backslash
n")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Para escrever um número temos primeiro que convertê-lo em cadeia de caracteres
\end_layout

\begin_layout Plain Layout

s=str(1642)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# E finalmente escrevê-lo no ficheiro
\end_layout

\begin_layout Plain Layout

fic.write(s)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Fechamos o ficheiro
\end_layout

\begin_layout Plain Layout

fic.close()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Agora sempre que quisermos chamar o ficheiro usamos 
\begin_inset Quotes eld
\end_inset

fic
\begin_inset Quotes erd
\end_inset

.
 Devem ter reparado no 
\begin_inset Quotes eld
\end_inset

w
\begin_inset Quotes erd
\end_inset

 que vem do inglês write, isto quer dizer que abrimos um ficheiro para escrever
 nele (caso já exista um ficheiro com esse nome o Python apaga todo o seu
 conteúdo).
 No lugar do 
\begin_inset Quotes eld
\end_inset

w
\begin_inset Quotes erd
\end_inset

, poderiamos usar um 
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

 do inglês read e nesse caso só poderíamos ler o ficheiro.
 Ou 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 de append, logo qualquer coisa que escrevamos vai imediatamente para o
 fim do ficheiro.
 E 
\begin_inset Quotes eld
\end_inset

r+
\begin_inset Quotes erd
\end_inset

 que nos permite ler e escrever.
\end_layout

\begin_layout Standard
Para ler o ficheiro podemos usar:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Abrimos o ficheiro dados.txt em modo de leitura
\end_layout

\begin_layout Plain Layout

fic=open("dados.txt","r")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Lemos a primeira e depois a segunda linha
\end_layout

\begin_layout Plain Layout

print fic.readline()
\end_layout

\begin_layout Plain Layout

print fic.readline()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Fechamos o ficheiro
\end_layout

\begin_layout Plain Layout

fic.close()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O comando fic.readline() lê uma linha e passa para a seguinte.
 O comando fic.read() lê o ficheiro completo e retorna-o numa cadeia de caractere
s.
 O fic.readlines() lê também o ficheiro completo mas devolve uma lista cujos
 elementos são as linhas.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{ex}
\end_layout

\end_inset

Crie uma tabela com os pontos do gráfico do seno entre 
\begin_inset Formula $0$
\end_inset

 e 
\begin_inset Formula $\pi$
\end_inset

 com mil pontos.
 Imprimi-la num ficheiro.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{ex}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Soluções
\end_layout

\begin_layout Section
Soluções do capítulo 2
\end_layout

\begin_layout Enumerate
Basta escrever no interpretador 4.5*3.14+3.4**2.1 o que resulta em 27.194889045094623.
\end_layout

\begin_layout Enumerate
O primeiro vale 1 e o segundo vale 1.505.
 O que acontece é que no primeiro caso ele está a dividir dois números inteiros
 e então o resultado também vai ser um inteiro.
\end_layout

\begin_layout Enumerate
A resposta é 7-2354785%7 que é igual a 1.
\end_layout

\begin_layout Enumerate
m não muda, logo obtém-se 3.
\end_layout

\begin_layout Enumerate
frase=
\begin_inset Quotes erd
\end_inset

Das uvas se faz vinho!
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
frase=frase[:4]+
\begin_inset Quotes erd
\end_inset

macas
\begin_inset Quotes erd
\end_inset

+frase[8:16]+
\begin_inset Quotes erd
\end_inset

cidra!
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
Se criarmos a lista A=[1,2,3] e B=[4,5,6], A.append(B) vai-nos dar A=[1,2,3,[4,5,
6]], ou seja, o quarto elemento da nova lista A vai ser [4,5,6].
\end_layout

\begin_layout Enumerate
Por exemplo X=range(1,51).
\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

n=3
\end_layout

\begin_layout Plain Layout

m=2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "Se n=",n,"e m=",m,", então nxm=",n*m 
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Começamos por pedir os dois valores ao utilizador
\end_layout

\begin_layout Plain Layout

x_min=input("Escreve o primeiro número: ")
\end_layout

\begin_layout Plain Layout

x_max=input("Escreve o último número: ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Imprimimos o resultado
\end_layout

\begin_layout Plain Layout

print range(x_min,x_max+1)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Passo por passo:
\end_layout

\begin_deeper
\begin_layout Enumerate
Criamos uma variável numérica com valor 56;
\end_layout

\begin_layout Enumerate
Transformamo-la numa cadeia que vale 
\begin_inset Quotes eld
\end_inset

56
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Enumerate
Duplicamos a cadeia: 
\begin_inset Quotes eld
\end_inset

5656
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Enumerate
Transformamos a cedeia no número 5656;
\end_layout

\begin_layout Enumerate
Duplicamos o número para 11312 e imprimimos.
\end_layout

\end_deeper
\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Criamos a função quadrado
\end_layout

\begin_layout Plain Layout

def quadrado(x)
\end_layout

\begin_layout Plain Layout

  return x**2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pedimos um número ao utilizador
\end_layout

\begin_layout Plain Layout

m=input("Escreva um número: ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Devolvemos o seu factorial
\end_layout

\begin_layout Plain Layout

print m,"ao quadrado é igual a ",quadrado(m)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Criamos a função factorial
\end_layout

\begin_layout Plain Layout

def fac(n)
\end_layout

\begin_layout Plain Layout

  if n==1: 
\end_layout

\begin_layout Plain Layout

    return 1
\end_layout

\begin_layout Plain Layout

  return n*fac(n-1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pedimos um número ao utilizador
\end_layout

\begin_layout Plain Layout

m=input("Escreva um número: ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Devolvemos o seu factorial
\end_layout

\begin_layout Plain Layout

print m,"factorial vale",fac(m)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Pedimos um número
\end_layout

\begin_layout Plain Layout

n=input("Escreva um número inteiro: ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Verificamos se ele é par ou impar
\end_layout

\begin_layout Plain Layout

if n%2==0:
\end_layout

\begin_layout Plain Layout

  print n,"é par."
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

  print n,"é impar."
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Pedimos ambos os números
\end_layout

\begin_layout Plain Layout

n=input("Escreva um número: ")
\end_layout

\begin_layout Plain Layout

m=input("E um segundo número: ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (n>0 or m>0) and n*m<=0:
\end_layout

\begin_layout Plain Layout

  print "Um e só um é positivo."
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Criamos os naipes e os valores das cartas:
\end_layout

\begin_layout Plain Layout

naipe=["paus","ouros","copas","espadas"]
\end_layout

\begin_layout Plain Layout

valor=["Ás","Duque","Terno","Quadra","Quina","Sena","Bisca","Valete","Dama","Rei
"]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Imprimimos as cartas todas
\end_layout

\begin_layout Plain Layout

for r in valor:
\end_layout

\begin_layout Plain Layout

  for s in naipe:
\end_layout

\begin_layout Plain Layout

    print r,"de",s
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Pedimos um número
\end_layout

\begin_layout Plain Layout

n=input("Escreva o número natural supostamente primo: ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# p é uma variável auxiliar que valerá um se n não for primo.
\end_layout

\begin_layout Plain Layout

p=0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Verificamos se n é maior que 1 e inteiro
\end_layout

\begin_layout Plain Layout

if n>1 and n%1==0:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Para todos os i entre 2 e n/2 testamos se é divisível
\end_layout

\begin_layout Plain Layout

  for i in range(2,n/2+1):
\end_layout

\begin_layout Plain Layout

    if n%i==0:
\end_layout

\begin_layout Plain Layout

      print "O número",n,"é divisível por",i
\end_layout

\begin_layout Plain Layout

      p=1
\end_layout

\begin_layout Plain Layout

      break
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Se p continuar nulo é porque n é primo
\end_layout

\begin_layout Plain Layout

  if p==0:
\end_layout

\begin_layout Plain Layout

    print "O número",n,"é primo."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Tratamos o caso da unidade à parte
\end_layout

\begin_layout Plain Layout

elif n==1: 
\end_layout

\begin_layout Plain Layout

  print "A unidade não é um número primo."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Só nos resta os número não inteiros positivos
\end_layout

\begin_layout Plain Layout

else: 
\end_layout

\begin_layout Plain Layout

  print "O número não é inteiro positivo."
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

Como podem verificar este método é lento para números muito grandes, pois
 ele tem que construir uma lista do tamanho de n mesmo que o número seja
 par.
 Um ciclo while (que aparece no capítulo a seguir) seria mais adequado:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Pedimos um número
\end_layout

\begin_layout Plain Layout

n=input("Escreva o número natural supostamente primo: ")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def primo(n):
\end_layout

\begin_layout Plain Layout

  i=2
\end_layout

\begin_layout Plain Layout

  while(i<=n/2):
\end_layout

\begin_layout Plain Layout

    if n%i==0:
\end_layout

\begin_layout Plain Layout

      print n,"é divísivel por",i
\end_layout

\begin_layout Plain Layout

      return 0
\end_layout

\begin_layout Plain Layout

  i=i+1
\end_layout

\begin_layout Plain Layout

  return 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Verificamos se n é maior que 1 e inteiro
\end_layout

\begin_layout Plain Layout

if n>1 and n%1==0:
\end_layout

\begin_layout Plain Layout

  if primo(n)==1:
\end_layout

\begin_layout Plain Layout

    print n,"é primo."
\end_layout

\begin_layout Plain Layout

elif n==1:
\end_layout

\begin_layout Plain Layout

  print "A unidade não é um número primo."
\end_layout

\begin_layout Plain Layout

else: 
\end_layout

\begin_layout Plain Layout

  print "O número não é inteiro positivo."
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Vamos procurar primos até a N_max
\end_layout

\begin_layout Plain Layout

N_max=2000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Verifica se n é primo.
 Devolve 1 se n for primo e 0 senão
\end_layout

\begin_layout Plain Layout

def primo(n):
\end_layout

\begin_layout Plain Layout

  for i in range(2,n/2+1):
\end_layout

\begin_layout Plain Layout

    if n%i==0:
\end_layout

\begin_layout Plain Layout

      return 0
\end_layout

\begin_layout Plain Layout

  return 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# O principal do programa
\end_layout

\begin_layout Plain Layout

for n in range(2,N_max+1):
\end_layout

\begin_layout Plain Layout

  if primo(n)==1:
\end_layout

\begin_layout Plain Layout

    print n
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# n é o número a calcular a raiz quadrada, e é uma espécie de precisão
\end_layout

\begin_layout Plain Layout

n=5
\end_layout

\begin_layout Plain Layout

e=0.0005
\end_layout

\begin_layout Plain Layout

m=1
\end_layout

\begin_layout Plain Layout

print "Queremos calcular a raiz quadrada de",n
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Enquanto a aproximação for má, ele continua
\end_layout

\begin_layout Plain Layout

while m**2>e**2:
\end_layout

\begin_layout Plain Layout

  p=input("Escreva um número: ")
\end_layout

\begin_layout Plain Layout

  m=p**2-n
\end_layout

\begin_layout Plain Layout

  print "A sua previsão falhou por:"m
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Imprime o resultado
\end_layout

\begin_layout Plain Layout

print "A raiz quadrada é",p
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# n é o número a calcular a raiz quadrada, e é uma espécie de precisão
\end_layout

\begin_layout Plain Layout

n=5
\end_layout

\begin_layout Plain Layout

e=0.000005
\end_layout

\begin_layout Plain Layout

r=1
\end_layout

\begin_layout Plain Layout

print "Queremos calcular a raiz quadrada de",n
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Enquanto a aproximação for má, ele continua
\end_layout

\begin_layout Plain Layout

while (r**2-n)**2>e**2:
\end_layout

\begin_layout Plain Layout

  r=0.5*(r+n/r)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Imprime o resultado
\end_layout

\begin_layout Plain Layout

print "A raiz quadrada é",r
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Soluções do capítulo 3
\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Vamos buscar o coseno e o pi
\end_layout

\begin_layout Plain Layout

from math import cos, pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Definimos o número de pontos
\end_layout

\begin_layout Plain Layout

p=20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Imprimimos o resultado
\end_layout

\begin_layout Plain Layout

for i in range(p):
\end_layout

\begin_layout Plain Layout

  print cos(i*pi/p)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Vamos buscar o coseno e o pi e carregamos o módulo pylab
\end_layout

\begin_layout Plain Layout

from math import cos, pi
\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Definimos o número de pontos
\end_layout

\begin_layout Plain Layout

p=5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Criamos X e Y
\end_layout

\begin_layout Plain Layout

Y=[]
\end_layout

\begin_layout Plain Layout

X=[]
\end_layout

\begin_layout Plain Layout

for i in range(p):
\end_layout

\begin_layout Plain Layout

  Y.append(cos(i*pi/p))
\end_layout

\begin_layout Plain Layout

  X.append(i*pi/p)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Desenhamos o gráfico
\end_layout

\begin_layout Plain Layout

pylab.plot(X,Y)
\end_layout

\begin_layout Plain Layout

pylab.show()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Aquilo a que chamamos embelezar o gráfico é extremamente subjectico.
 Aqui vão algumas dicas:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

from math import cos, pi
\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

p=1000
\end_layout

\begin_layout Plain Layout

Y=[]
\end_layout

\begin_layout Plain Layout

X=[]
\end_layout

\begin_layout Plain Layout

for i in range(p):
\end_layout

\begin_layout Plain Layout

  Y.append(cos(i*pi/p))
\end_layout

\begin_layout Plain Layout

  X.append(i*pi/p)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria uma linha de nome cos, com espessura 2, tracejada e vermelha
\end_layout

\begin_layout Plain Layout

pylab.plot(X,Y,"--r",label="cos",linewidth=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Dá um título
\end_layout

\begin_layout Plain Layout

pylab.title("Grafico do coseno de x")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Nomeamos o eixo das abcissas de x
\end_layout

\begin_layout Plain Layout

pylab.xlabel("x")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Nomeamos o eixo das ordenadas de y e rodamos o nome
\end_layout

\begin_layout Plain Layout

pylab.ylabel("y",rotation="horizontal")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Criamos uma legenda
\end_layout

\begin_layout Plain Layout

pylab.legend()
\end_layout

\begin_layout Plain Layout

pylab.show()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8 
\end_layout

\begin_layout Plain Layout

from visual import * 
\end_layout

\begin_layout Plain Layout

from math import * 
\end_layout

\begin_layout Plain Layout

import time
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n=10       #Número de actualizações por segundo 
\end_layout

\begin_layout Plain Layout

t=200      #Tempo que dura a animação 
\end_layout

\begin_layout Plain Layout

r=1+sin(0) #Raio inicial
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Definimos uma esfera 
\end_layout

\begin_layout Plain Layout

bola=sphere(pos=(0,0,0),radius=r,color=color.red)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Fixamos o tamanho da janela 
\end_layout

\begin_layout Plain Layout

scene.range=(3,3,3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Actualizamos o raio da esfera 
\end_layout

\begin_layout Plain Layout

for i in range(n*t): 
\end_layout

\begin_layout Plain Layout

 time.sleep(1./n) #Faz uma pausa de 1/n segundos 
\end_layout

\begin_layout Plain Layout

 r=1+sin(i*0.2*pi/n) 
\end_layout

\begin_layout Plain Layout

 bola.radius=r
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Código:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

# Vamos buscar o coseno e o pi
\end_layout

\begin_layout Plain Layout

from math import cos, pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Criamos um ficheiro
\end_layout

\begin_layout Plain Layout

fic=open("dados.txt","w")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Definimos o número de pontos
\end_layout

\begin_layout Plain Layout

p=1000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Imprimimos o resultado
\end_layout

\begin_layout Plain Layout

for i in range(p):
\end_layout

\begin_layout Plain Layout

  s=str(i*pi/p)+"  "+str(cos(i*pi/p))+"
\backslash
n"
\end_layout

\begin_layout Plain Layout

  fic.write(s)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Fechamos o ficheiro
\end_layout

\begin_layout Plain Layout

fic.close()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Passeio Aleatório
\end_layout

\begin_layout Standard
Neste capítulo vai ser apresentado um modelo estatístico adequado a explicar
 o movimento Browniano.
 Vamos começar por estudar o problema do passeio aleatório, o qual é a base
 do nosso modelo, e depois aplicá-lo ao estudo do movimento Browniano.
\end_layout

\begin_layout Section
Experiência
\end_layout

\begin_layout Standard
Começemos por uma experiência conceptual.
 Imaginem alguem que ingeriu uma grande quantidade de bebidas alcoólicas,
 ao ponto de perder completamente o seu sentido de orientação.
 Imaginemos que este, devido à sua falta de equilíbrio, em cada instante
 de tempo dá um passo numa direcção aleatória.
 A nossa pergunta é: ao fim de um dado tempo, e a que distância estará este
 da sua posição inicial e qual a sua posição média? (neste caso vai-nos
 interessar o quadrado desta distância, também chamado de desvio quadrático.
 Vai ser claro porquê mais à frente.)
\end_layout

\begin_layout Standard
Para responder a esta pergunta, podemos utilizar os nossos conhecimentos
 de python e fazer um programa que simule esta situação improvável de observar
 na vida real.
\end_layout

\begin_layout Standard
Começemos por definir o nosso problema de um modo mais formal: queremos
 calcular uma trajectória com N passos, onde em cada um deles se dá um passo
 numa direcção aleatória.
 Queremos também calcular o desvio quadrático e a sua posição média ao longo
 dos N passos.
 Para simplificar vamos assumir que só existem 4 direcções possívels: cima,
 baixo, esquerda e direita.
 Como implementar isto? 
\end_layout

\begin_layout Itemize
Qual a maneira mais indicada para guardar os dados da trajectória e desvio
 quadrático? Necessitamos de guardar N valores de x, y, x médio, y médio
 e 
\begin_inset Formula $r^{2}$
\end_inset

.
 A maneira mais imediata de fazer isto é usar uma lista.
 
\end_layout

\begin_layout Itemize
O facto de haverem N passos implica que temos de fazer um ciclo, que corre
 N vezes, adicionando um ponto à trajectória de cada vez.
\end_layout

\begin_layout Itemize
É necessário escolher direcções aleatórias - logo será necessário gerar
 números aleatórios, e fazer uma decisão consoante o resultado.
\end_layout

\begin_layout Standard
Uma implementação possível:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

import random
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria as listas que representam a nossa trajectória x,y 
\end_layout

\begin_layout Plain Layout

# inicialmente estamos no ponto (0,0) 
\end_layout

\begin_layout Plain Layout

x = 0
\end_layout

\begin_layout Plain Layout

y = 0
\end_layout

\begin_layout Plain Layout

trajectoria_x = [0] 
\end_layout

\begin_layout Plain Layout

trajectoria_y = [0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Cria a lista do R^2, x médio e y médio
\end_layout

\begin_layout Plain Layout

R2      = [0]
\end_layout

\begin_layout Plain Layout

soma_x  = 0
\end_layout

\begin_layout Plain Layout

x_medio = [0]
\end_layout

\begin_layout Plain Layout

soma_y  = 0
\end_layout

\begin_layout Plain Layout

y_medio = [0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N = 1000
\end_layout

\begin_layout Plain Layout

# Adiciona um ponto novo à trajectória N vezes
\end_layout

\begin_layout Plain Layout

for i in xrange(N):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Adiciona valores as listas com os dados de x e y da nossa trajectória
\end_layout

\begin_layout Plain Layout

    # segundo um passeio aleatorio
\end_layout

\begin_layout Plain Layout

    p = random.random()*4
\end_layout

\begin_layout Plain Layout

    if(p < 1):
\end_layout

\begin_layout Plain Layout

        x = x + 1
\end_layout

\begin_layout Plain Layout

    elif(p < 2):
\end_layout

\begin_layout Plain Layout

        x = x - 1
\end_layout

\begin_layout Plain Layout

    elif(p < 3):
\end_layout

\begin_layout Plain Layout

        y = y + 1
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        y = y - 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    trajectoria_x.append(x)
\end_layout

\begin_layout Plain Layout

    trajectoria_y.append(y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    R2.append(x**2 + y**2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    soma_x += x
\end_layout

\begin_layout Plain Layout

    x_medio.append(soma_x/(i+1))
\end_layout

\begin_layout Plain Layout

    soma_y += y
\end_layout

\begin_layout Plain Layout

    y_medio.append(soma_y/(i+1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#força o gráfico a ter um aspecto rectangular 14x4
\end_layout

\begin_layout Plain Layout

pylab.figure(0,figsize=(14,4))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Desenha um linha com a trajectória 
\end_layout

\begin_layout Plain Layout

pylab.subplot(131)
\end_layout

\begin_layout Plain Layout

pylab.title('Trajectoria')
\end_layout

\begin_layout Plain Layout

pylab.plot(trajectoria_x,trajectoria_y) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Desenha o gráfico do x médio e y médio
\end_layout

\begin_layout Plain Layout

pylab.subplot(132)
\end_layout

\begin_layout Plain Layout

pylab.title('X e Y medios em funcao do tempo')
\end_layout

\begin_layout Plain Layout

pylab.plot(x_medio) 
\end_layout

\begin_layout Plain Layout

pylab.plot(y_medio)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Desenha o gráfico do R^2
\end_layout

\begin_layout Plain Layout

pylab.subplot(133)
\end_layout

\begin_layout Plain Layout

pylab.title('r**2 em funcao do tempo')
\end_layout

\begin_layout Plain Layout

pylab.plot(R2) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pylab.show()
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Usando este programa, que resultados obtemos? Dois resultados possíveis,
 com N=5000 e N=100000:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename brown_exemplo1_5000.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename brown_exemplo1_10000.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
A trajectória parece caótica, sem nenhum padrão óbvio.
 De facto, executando o programa várias vezes e observando várias trajectórias
 diferentes não há muitas conclusões que se possam tirar.
 Mesmo os gráficos do x e y médios são 
\emph on
geralmente 
\emph default
diferentes do que esperariamos intuitivamente: se há a mesma probabilidade
 de andar para um lado que para o outro, seria de esperar que em média o
 deslocamento fosse 0.
 
\end_layout

\begin_layout Standard
Vemos assim que não é muito vantajoso analisarmos o problema em termos de
 uma só partícula.
 Na verdade é apenas quando se faz uma estatística sob a trajectória de
 várias partículas que o problema fica interessante.
 
\end_layout

\begin_layout Section
Vários Caminhantes
\end_layout

\begin_layout Standard
Imaginemos o mesmo problema, mas em vez de termos apenas um bêbado temos
 uma comitiva de M bêbados.
 Queremos estudar os seus deslocamentos médios em x e y (num dado instante
 de tempo, não ao longo do tempo como no exemplo anterior) e a média dos
 seus desvios quadráticos.
 Usemos outra vez o python para resolver o problema.
 Agora em vez de haver apenas um caminhante, existem M caminhantes, logo
 M posições x,y.
 Como não vamos fazer os gráficos das trajectórias, apenas necessitamos
 de guardar a posição corrente dos caminhantes, ao contrário do exemplo
 anterior que guardavamos a trajectória ao longo do tempo.
 Assim, podemos utilizar uma lista para guardar todos os valores de x num
 dado instante de tempo (e outra para y).
\end_layout

\begin_layout Standard
Uma implementação possível:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pylab 
\end_layout

\begin_layout Plain Layout

import random
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Número de Caminhantes
\end_layout

\begin_layout Plain Layout

M = 50
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria as listas que vão conter os pontos x_i,y_i no último instante de
 tempo
\end_layout

\begin_layout Plain Layout

trajectorias_x = []
\end_layout

\begin_layout Plain Layout

trajectorias_y = []
\end_layout

\begin_layout Plain Layout

# Adiciona M pontos iniciais às trajectórias
\end_layout

\begin_layout Plain Layout

for j in range(M):
\end_layout

\begin_layout Plain Layout

    trajectorias_x.append(0)
\end_layout

\begin_layout Plain Layout

    trajectorias_y.append(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Cria a lista do R^2, x médio e y médio
\end_layout

\begin_layout Plain Layout

R2      = [0]
\end_layout

\begin_layout Plain Layout

x_medio = [0]
\end_layout

\begin_layout Plain Layout

y_medio = [0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N = 1000 
\end_layout

\begin_layout Plain Layout

# Processa pontos novos N vezes
\end_layout

\begin_layout Plain Layout

for i in xrange(N):
\end_layout

\begin_layout Plain Layout

    # Adiciona valores as listas com os dados de x e y das nossas trajectórias
\end_layout

\begin_layout Plain Layout

     # segundo um passeio aleatorio
\end_layout

\begin_layout Plain Layout

    for j in range(M):
\end_layout

\begin_layout Plain Layout

        p = random.random()*4
\end_layout

\begin_layout Plain Layout

        if(p < 1):
\end_layout

\begin_layout Plain Layout

            trajectorias_x[j] = trajectorias_x[j] + 1
\end_layout

\begin_layout Plain Layout

        elif(p < 2):
\end_layout

\begin_layout Plain Layout

            trajectorias_x[j] = trajectorias_x[j] - 1
\end_layout

\begin_layout Plain Layout

        elif(p < 3):
\end_layout

\begin_layout Plain Layout

            trajectorias_y[j] = trajectorias_y[j] + 1
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            trajectorias_y[j] = trajectorias_y[j] - 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Calcula a média dos desvios quadráticos
\end_layout

\begin_layout Plain Layout

    soma_R2 = 0.
\end_layout

\begin_layout Plain Layout

    for k in range(M):
\end_layout

\begin_layout Plain Layout

        soma_R2 = soma_R2 + trajectorias_x[k]**2+trajectorias_y[k]**2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    R2.append(soma_R2/M)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Calcula a posição média entre as partículas
\end_layout

\begin_layout Plain Layout

    soma_x = 0.
\end_layout

\begin_layout Plain Layout

    soma_y = 0.
\end_layout

\begin_layout Plain Layout

    for l in range(M):
\end_layout

\begin_layout Plain Layout

        soma_x = soma_x + trajectorias_x[l]
\end_layout

\begin_layout Plain Layout

        soma_y = soma_y + trajectorias_y[l]
\end_layout

\begin_layout Plain Layout

    x_medio.append(soma_x/M)
\end_layout

\begin_layout Plain Layout

    y_medio.append(soma_y/M)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#força o gráfico a ter um aspecto rectangular 10x4
\end_layout

\begin_layout Plain Layout

pylab.figure(0,figsize=(10,4))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Desenha o gráfico do x médio e y médio
\end_layout

\begin_layout Plain Layout

pylab.subplot(121)
\end_layout

\begin_layout Plain Layout

pylab.plot(x_medio)
\end_layout

\begin_layout Plain Layout

pylab.plot(y_medio)
\end_layout

\begin_layout Plain Layout

pylab.title('X e Y medios em funcao do tempo') 
\end_layout

\begin_layout Plain Layout

#força a escala em y de -10 a 10 
\end_layout

\begin_layout Plain Layout

pylab.ylim((-10,10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Desenha o gráfico do R^2
\end_layout

\begin_layout Plain Layout

pylab.subplot(122)
\end_layout

\begin_layout Plain Layout

pylab.plot(R2)
\end_layout

\begin_layout Plain Layout

pylab.title('r**2 medio em funcao do tempo')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pylab.show()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vejamos resultados possíveis.
 Para N=1000 (pontos da trajectória), M=1 (número de caminhantes):
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename brown_exemplo2_1.png
	lyxscale 40
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
Apenas um caminhante.
 O resultado é semelhante ao do exemplo anterior.
 Para N = 1000, M=10:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename brown_exemplo2_10.png
	lyxscale 40
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
Para N = 1000, M = 50:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename brown_exemplo2_50.png
	lyxscale 40
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
Para N = 1000, M = 500:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename brown_exemplo2_500.png
	lyxscale 40
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
Ao aumentarmos o número de caminhantes, vemos duas tendências claras: a
 média dos deslocamentos das partículas mantem-se cada vez mais próxima
 de zero durante as trajectórias e o desvio quadrático médio torna-se cada
 vez mais próximo de uma recta.
 Estes resultados implicam que, em média, as partículas se afastam da posição
 inicial, de maneira que a média quadrado da distância a esta posição inicial
 cresca linearmente com o tempo.
 Este resultado é concordante com o que Einstein derivou em 1905 na sua
 publicação: 'Investigações na teoria do movimento browniano', a qual explicou
 o movimento errático de partículas de polen suspensas em água com argumentos
 baseados em moléculas e átomos, conceitos bastante disputados na altura.
 
\end_layout

\begin_layout Standard
Assim, pode-se dizer que este modelo simples do passeio aleatório e a teoria
 desenvolvida por Einstein dão uma explicação para o comportamento dos grãos
 de polen de brown, de maneira a reforçar a credibilidade da ideia que a
 matéria é composta por átomos.
 Este foi um passo importante para a ciência no início do século XX.
\end_layout

\begin_layout Section
Previsão
\end_layout

\begin_layout Standard
Não fiquemos por aqui.
 Usemos o nosso modelo teórico para prever o que acontece noutras situações.
 Por exemplo, imaginem grãos de polen suspensos em água.
 Estes estão sujeitos a uma grande quantidade de choques por parte das moléculas
 de água, logo idealmente vão descrever movimento browniano.
 Mas o que acontece quando se encontram numa superfície inclinada, ou quando
 existe uma pequena corrente na água para um dos lados? Naturalmente as
 suas trajectórias serão mais direccionadas para uma das direcções.
 
\end_layout

\begin_layout Standard
Como podemos inserir isto no nosso modelo? Uma maneira será atribuir uma
 maior probabilidade de o caminhante se deslocar para um dos lados do que
 para os outros.
 Isto pode ser feito substituindo, no exemplo anterior, a linha:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

        p = random.random()*4
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

        p = random.random()*5 #ou um número maior
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Assim, a probabilidade do caminhante se deslocar para baixo será o dobro
 das outras direcções.
 Porquê? Vejamos os resultados possíveis: se sair um número entre 0 e 1,
 vai para a direita, entre 1 e 2, vai para a esquerda, 2 e 3, cima, 3 e
 5, baixo.
 Como é duas vezes mais provável ir para baixo do que ir para uma das outras
 direcções, o efeito é equivalente à presença de inclinação ou fluxo de
 água.
 Um resultado possível, com N=1000 e M=500 será:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename brown_exemplo3.png
	lyxscale 40
	width 100col%

\end_inset


\end_layout

\begin_layout Standard
Vemos que o y médio decresceu quase linearmente ao longo do tempo, tal como
 num movimento rectilíneo.
 Não surpreendentemente, a média de 
\begin_inset Formula $r^{2}$
\end_inset

 aumenta quadráticamente, tal como no movimento rectilíneo (se a posição
 é 
\begin_inset Formula $x=0,y=mt$
\end_inset

, o desvio quadrático será 
\begin_inset Formula $r^{2}=x^{2}+y^{2}=m^{2}t^{2}$
\end_inset

, quadrático no tempo).
 Assim, se fizermos uma experiência seguindo as trajectórias de partículas
 em água , e calculando o desvio quadrático médio, esperamos um gráfico
 com uma recta caso a amostra esteja nivelada e sem correntes ou uma parábola
 caso contrário.
 
\end_layout

\begin_layout Chapter
Da ordem ao caos
\end_layout

\begin_layout Standard
Segundo a física clássica o nosso mundo é determinístico.
 Ou seja, se nós repetirmos a mesma experiência nas mesmas condições vamos
 obter exactamente os mesmos resultados.
 Porém não somos capazes de prever tudo.
 Porquê? Esta dificuldade em prever certos fenómenos surge, de entre outras
 causas, do caos.
\end_layout

\begin_layout Standard
Para perceber donde surge o caos, propomos aqui um exemplo simples.
\end_layout

\begin_layout Section
O problema da pirâmide
\end_layout

\begin_layout Standard
Imaginemos um pequeno jogo.
 
\end_layout

\begin_layout Standard
Temos uma pirâmide de tubos, tal como mostra a figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:piramide"

\end_inset

, abertos em baixo e em cima.
 Deixamos cair uma bola por entre os tubos e deixamo-la cair por entre os
 tubos até que por fim ela 
\begin_inset Quotes eld
\end_inset

se decida
\begin_inset Quotes erd
\end_inset

 a parar numa certa caixa.
 Agora queremos adivinhar que caixa é essa.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Graphics
	filename piramide.eps
	scale 50

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:piramide"

\end_inset

Neste exemplo, a bola cai no primeiro tubo e vai batendo nas várias paredes
 até chegar à caixa 4.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Infelizmente o problema é ainda muito complicado para ser tratado com todo
 o pormenor em apenas uma semana.
 Por isso, em 2008, decidimos simplificar o modelo desprezando a gravidade.
\end_layout

\begin_layout Subsection
Caixa final
\end_layout

\begin_layout Standard
Para calcular a que caixa a bola chega utilizamos, em 2008, o seguinte programa:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x=0.59864 #posição de entrada
\end_layout

\begin_layout Plain Layout

b=5.12653 #comprimento do tubo
\end_layout

\begin_layout Plain Layout

w=.301 #tangente do ângulo inicial
\end_layout

\begin_layout Plain Layout

n=100 #nº de níveis
\end_layout

\begin_layout Plain Layout

#a espessura dos tubos é 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

num=0 #indicador do número da caixa  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# saida(x,w) é uma função auxiliar que 
\end_layout

\begin_layout Plain Layout

# calcula a posição e o ângulo de saída para cada tubo 
\end_layout

\begin_layout Plain Layout

# sabendo a posição e o ângulo de entrada neste
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def saida(x,w):
\end_layout

\begin_layout Plain Layout

  y=w*b+x #posição final se o tubo não tivesse paredes
\end_layout

\begin_layout Plain Layout

  n=int(y) #devolve a parte inteira de y
\end_layout

\begin_layout Plain Layout

  d=y-n #
\end_layout

\begin_layout Plain Layout

  if y>=0:
\end_layout

\begin_layout Plain Layout

    if n%2==0:
\end_layout

\begin_layout Plain Layout

      wf=w
\end_layout

\begin_layout Plain Layout

      xf=d
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

      wf=-w
\end_layout

\begin_layout Plain Layout

      xf=1-d
\end_layout

\begin_layout Plain Layout

  else:
\end_layout

\begin_layout Plain Layout

    if n%2==0:
\end_layout

\begin_layout Plain Layout

      wf=-w
\end_layout

\begin_layout Plain Layout

      xf=-d
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

      wf=w
\end_layout

\begin_layout Plain Layout

      xf=1+d
\end_layout

\begin_layout Plain Layout

  return [xf,wf]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Calcula fila por fila onde está a bola
\end_layout

\begin_layout Plain Layout

for j in range(n):
\end_layout

\begin_layout Plain Layout

  r= saida(x,w)
\end_layout

\begin_layout Plain Layout

  if r[0]>0.5:
\end_layout

\begin_layout Plain Layout

    x=r[0]-0.5
\end_layout

\begin_layout Plain Layout

    num=num+1 
\end_layout

\begin_layout Plain Layout

  else:
\end_layout

\begin_layout Plain Layout

    x=0.5+r[0]
\end_layout

\begin_layout Plain Layout

  w=r[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#resultado final
\end_layout

\begin_layout Plain Layout

print num
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Trajectória da bola
\end_layout

\begin_layout Standard
Para desenhar a trajectória bastou-nos registar a posição a cada nível e
 no fim fazer um gráfico:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

import math
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x=0.59864 #posiçao de entrada
\end_layout

\begin_layout Plain Layout

b=5.12653 #comprimento
\end_layout

\begin_layout Plain Layout

w=.301 #tangente do ângulo inicial
\end_layout

\begin_layout Plain Layout

n=100 #nº de níveis 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#a espessura dos tubos é 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

titulo="Tangente do angulo ="+str(w) #titulo do gráfico
\end_layout

\begin_layout Plain Layout

nome="traj_"+str(int(1000*w)) #nome do ficheiro
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

num=0 #indicador do número da caixa 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pos_x=[] #abcissa = número da caixa 
\end_layout

\begin_layout Plain Layout

Pos_y=[] #ordenada = nível 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#e=0.01
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#calculo a posição e o ângulo de saída para cada tubo 
\end_layout

\begin_layout Plain Layout

#sabendo a posição e o ângulo de entrada
\end_layout

\begin_layout Plain Layout

def saida(x,w):
\end_layout

\begin_layout Plain Layout

  y=w*b+x
\end_layout

\begin_layout Plain Layout

#int() devolve a parte inteira de y
\end_layout

\begin_layout Plain Layout

  n=int(y)
\end_layout

\begin_layout Plain Layout

  d=y-n
\end_layout

\begin_layout Plain Layout

  if y>=0:
\end_layout

\begin_layout Plain Layout

    if n%2==0:
\end_layout

\begin_layout Plain Layout

      wf=w
\end_layout

\begin_layout Plain Layout

      xf=d
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

      wf=-w
\end_layout

\begin_layout Plain Layout

      xf=1-d
\end_layout

\begin_layout Plain Layout

  else:
\end_layout

\begin_layout Plain Layout

    if n%2==0:
\end_layout

\begin_layout Plain Layout

      wf=-w
\end_layout

\begin_layout Plain Layout

      xf=-d
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

      wf=w
\end_layout

\begin_layout Plain Layout

      xf=1+d
\end_layout

\begin_layout Plain Layout

  return [xf,wf]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#calcula fila por fila onde está a bola
\end_layout

\begin_layout Plain Layout

for j in range(n):
\end_layout

\begin_layout Plain Layout

  r= saida(x,w)
\end_layout

\begin_layout Plain Layout

  #b=b+e #varia o tamanho do cilindro, aumenta a imprevisibilidade
\end_layout

\begin_layout Plain Layout

  if r[0]>0.5:
\end_layout

\begin_layout Plain Layout

    x=r[0]-0.5
\end_layout

\begin_layout Plain Layout

    num=num+1
\end_layout

\begin_layout Plain Layout

  else:
\end_layout

\begin_layout Plain Layout

    x=0.5+r[0]
\end_layout

\begin_layout Plain Layout

  w=r[1]
\end_layout

\begin_layout Plain Layout

  Pos_y.append(n-j) #ordenadas da trajectória
\end_layout

\begin_layout Plain Layout

  Pos_x.append(num+(n-j)/2.) #abcissas da trajectória
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#desenha a trajectória
\end_layout

\begin_layout Plain Layout

pylab.plot(Pos_x,Pos_y)
\end_layout

\begin_layout Plain Layout

pylab.axis([0,n,0,n])
\end_layout

\begin_layout Plain Layout

pylab.title(titulo)
\end_layout

\begin_layout Plain Layout

pylab.savefig(nome)
\end_layout

\begin_layout Plain Layout

#pylab.show()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podemos ver na figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:traj"

\end_inset

 dois exemplos de trajectórias.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename traj_3010.png
	lyxscale 40
	scale 30

\end_inset


\begin_inset Graphics
	filename traj_3015.png
	lyxscale 40
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:traj"

\end_inset

Trajectórias para duas configurações quase idênticas.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Variando o ângulo
\end_layout

\begin_layout Standard
Para melhor testar a dependência do modelo nas condições iniciais, corremos
 o programa variando o ângulo inicial.
 Nesse intuíto alteramos o nosso programa:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

import math
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x=0.59864 #posiçao de entrada
\end_layout

\begin_layout Plain Layout

B=5.12653 #comprimento
\end_layout

\begin_layout Plain Layout

w_min=-1.343 #tangente do ângulo inicial mínimo
\end_layout

\begin_layout Plain Layout

w_max=1.124 #tangente do ângulo inicial máximo
\end_layout

\begin_layout Plain Layout

n=100 #nº de níveis 
\end_layout

\begin_layout Plain Layout

P=3000 #número de lançamentos
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#a espessura dos tubos é 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pos_x=[] #abcissa = tangente inicial 
\end_layout

\begin_layout Plain Layout

Pos_y=[] #ordenada = número da caixa
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#e=0.01
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#calculo a posição e o ângulo de saída para cada tubo 
\end_layout

\begin_layout Plain Layout

#sabendo a posição e o ângulo de entrada
\end_layout

\begin_layout Plain Layout

def saida(x,w):
\end_layout

\begin_layout Plain Layout

  y=w*b+x
\end_layout

\begin_layout Plain Layout

#int() devolve a parte inteira de y
\end_layout

\begin_layout Plain Layout

  n=int(y)
\end_layout

\begin_layout Plain Layout

  d=y-n
\end_layout

\begin_layout Plain Layout

  if y>=0:
\end_layout

\begin_layout Plain Layout

    if n%2==0:
\end_layout

\begin_layout Plain Layout

      wf=w
\end_layout

\begin_layout Plain Layout

      xf=d
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

      wf=-w
\end_layout

\begin_layout Plain Layout

      xf=1-d
\end_layout

\begin_layout Plain Layout

  else:
\end_layout

\begin_layout Plain Layout

    if n%2==0:
\end_layout

\begin_layout Plain Layout

      wf=-w
\end_layout

\begin_layout Plain Layout

      xf=-d
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

      wf=w
\end_layout

\begin_layout Plain Layout

      xf=1+d
\end_layout

\begin_layout Plain Layout

  return [xf,wf]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#percorre os vários ângulos
\end_layout

\begin_layout Plain Layout

for k in range(P):
\end_layout

\begin_layout Plain Layout

  w=w_min+(w_max-w_min)/P)*k
\end_layout

\begin_layout Plain Layout

  Pos_x.append(w) #tangente do ângulo de partida
\end_layout

\begin_layout Plain Layout

  num=0
\end_layout

\begin_layout Plain Layout

  b=B
\end_layout

\begin_layout Plain Layout

#calcula fila por fila onde está a bola
\end_layout

\begin_layout Plain Layout

  for j in range(n):
\end_layout

\begin_layout Plain Layout

    r= saida(x,w)
\end_layout

\begin_layout Plain Layout

    #b=b+e #varia o tamanho do cilindro, aumenta a impresibilidade
\end_layout

\begin_layout Plain Layout

    if r[0]>0.5:
\end_layout

\begin_layout Plain Layout

      x=r[0]-0.5
\end_layout

\begin_layout Plain Layout

      num=num+1
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

      x=0.5+r[0]
\end_layout

\begin_layout Plain Layout

    w=r[1]
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  Pos_y.append(num) #número da caixa
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#desenha o gráfico
\end_layout

\begin_layout Plain Layout

pylab.plot(Pos_x,Pos_y,".")
\end_layout

\begin_layout Plain Layout

pylab.xlabel("tangente do angulo inicial")
\end_layout

\begin_layout Plain Layout

pylab.ylabel("numero da caixa final")
\end_layout

\begin_layout Plain Layout

pylab.title("O numero da caixa final em funcao da tangente
\backslash
ncom a altura da caixa dependente do nivel")
\end_layout

\begin_layout Plain Layout

pylab.axis([-1.4,1.2,0,100])
\end_layout

\begin_layout Plain Layout

#pylab.savefig("caos")
\end_layout

\begin_layout Plain Layout

pylab.show() 
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Isto resulta no gráfico 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename caos.png
	lyxscale 40
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:caos"

\end_inset

Gráfico da variação do número da caixa final em função da tangente do ângulo
 inicial.
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Perguntas em aberto
\end_layout

\begin_layout Enumerate
O que acontece se em vez de variarmos o ângulo inicial variarmos a posição
 inicial?
\end_layout

\begin_layout Enumerate
Será que podemos considerar a gravidade? Vai aumentar ou diminuir a imprevisibil
idade?
\end_layout

\begin_layout Enumerate
Existe alguma forma de calcular a imprevisibilidade? Calcula duas trajectórias
 começando em condições semelhantes (mas não exactamente iguais) e veja
 como divergem.
 Repete a experiência várias vezes.
\end_layout

\begin_layout Enumerate
E se o tamanho da caixa fosse aleatório, mas pré-definido?
\end_layout

\begin_layout Enumerate
Qual é a probabilidade de a bola cair numa determinada posição?
\end_layout

\begin_layout Enumerate
Imaginemos a mesma experiência, mas na qual a bola 
\begin_inset Quotes eld
\end_inset

escolhe
\begin_inset Quotes erd
\end_inset

 ir para o tubo à esquerda ou à direita aleatoriamente.
 Como se comparam os resultados de ambas as experiências?
\end_layout

\begin_layout Section
Outros modelos
\end_layout

\begin_layout Standard
Na preparação deste projecto foram investigados vários modelos com característic
as semelhantes.
 O modelo da pirâmide foi escolhido por ser o mais adequado às pretenções
 da Escola de Verão, mas existem outros igualmente interessantes.
 Nesta secção fazemos uma pequena digressão sobre esses modelos.
\end_layout

\begin_layout Subsection
Sistemas dinâmicos e coelhos
\end_layout

\begin_layout Standard
Numa certa ilha deserta existe uma população de coelhos, a densidade de
 coelhos no momento 
\begin_inset Formula $n$
\end_inset

 é dada por 
\begin_inset Formula $u_{n}$
\end_inset

.
 É normal considerar que a taxa de natalidade dos coelhos seja proporcional
 à quantidade de coelhos existentes (
\begin_inset Formula $\sim u_{n}$
\end_inset

).
 Por outro lado, esperamos que a quantidade de coelhos dependa da quantidade
 de comida disponível.
 Por sua vez a quantidade de comida depende da concentração de coelhos (
\begin_inset Formula $\sim(1-u_{n})$
\end_inset

).
 Podemos então dizer que a concentração na segunda geração de coelhos é
 descrita pela equação:
\begin_inset Formula \[
u_{n+1}=A\ u_{n}(1-u_{n})\]

\end_inset


\end_layout

\begin_layout Standard
Apesar de parecer tão simples, esta equação esconde propriedades bastante
 interessantes.
 Para começar tem dois pontos fixos: 
\begin_inset Formula $u=0$
\end_inset

, se não há coelhos no início não há procriação; 
\begin_inset Formula $u=1-A^{-1}$
\end_inset

.
 Para 
\begin_inset Formula $A<3$
\end_inset

 (valor aproximado) o sistema converge sempre, depois tem um intervalo em
 que o sistema alterna entre dois pontos, três pontos...
 assim por diante, até que a partir de 
\begin_inset Formula $3.6$
\end_inset

 ele começa a visitar todos os pontos entre 0 e 1.
 Como se pode ver no gráfico
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "coelho"

\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Graphics
	filename coelhos.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "coelho"

\end_inset

Quando se varia a constante 
\begin_inset Formula $A$
\end_inset

, obtém-se resulatdos completamente diferentes, desde regiões convergentes
 até outras que são verdadeiramente caóticas.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
O código usado foi:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#          Este programa simula uma população de coelhos
\end_layout

\begin_layout Plain Layout

#                                                       
\end_layout

\begin_layout Plain Layout

#  A taxa de natalidade dos coelhos numa sociedade é proporcional 
\end_layout

\begin_layout Plain Layout

#       ao número de coelhos e à quantidade de comida, esta é      
\end_layout

\begin_layout Plain Layout

#  proporcional também ao número de coelhos, ficamos assim com uma 
\end_layout

\begin_layout Plain Layout

#               uma equação do tipo u->A u (1-u)                   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

num=200 #quantidade de interacções 
\end_layout

\begin_layout Plain Layout

Q=4 #1-Experiência Simples; 2-Variar número de coelhos; 
\end_layout

\begin_layout Plain Layout

    #3-Variar constante; 4-Varia ambos 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N_A=2000 #número de passos (variar a constante) 
\end_layout

\begin_layout Plain Layout

N_x=20 #número de passos (variar num de coelhos)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A_min=0.
 #constante mínima para 3 
\end_layout

\begin_layout Plain Layout

A_max=4.
 #constante máxima para 3 
\end_layout

\begin_layout Plain Layout

A=[1.0,2.0,3.0] #constante para 1 e 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n_min=0.1 #número de coelhos mínimo para 2 
\end_layout

\begin_layout Plain Layout

n_max=0.9 #número de coelhos máximo para 2 
\end_layout

\begin_layout Plain Layout

n=[0.7] #número de coelhos para 1 e 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#cálculo da interacção seguinte 
\end_layout

\begin_layout Plain Layout

def inter(a,u):
\end_layout

\begin_layout Plain Layout

	return a*u*(1-u)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#                  Calcula o número de coelhos 
\end_layout

\begin_layout Plain Layout

#    Desenha o gráfico da variação desse número em função do tempo 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def Simples():
\end_layout

\begin_layout Plain Layout

	X=range(num)
\end_layout

\begin_layout Plain Layout

	Y_num=[]
\end_layout

\begin_layout Plain Layout

	g=0
\end_layout

\begin_layout Plain Layout

	for a in A:
\end_layout

\begin_layout Plain Layout

		for x in n:
\end_layout

\begin_layout Plain Layout

			Y_num.append([])
\end_layout

\begin_layout Plain Layout

			s="numero="+str(x)+" e A="+str(a)
\end_layout

\begin_layout Plain Layout

			for j in range(num):
\end_layout

\begin_layout Plain Layout

				x=inter(a,x)
\end_layout

\begin_layout Plain Layout

				Y_num[g].append(x)
\end_layout

\begin_layout Plain Layout

			pylab.plot(X,Y_num[g],",",label=s)
\end_layout

\begin_layout Plain Layout

			g+=1
\end_layout

\begin_layout Plain Layout

	pylab.title("Numero de coelhos por interacao.")
\end_layout

\begin_layout Plain Layout

	pylab.xlabel("Interacao")
\end_layout

\begin_layout Plain Layout

	pylab.ylabel("Numero de coelhos")
\end_layout

\begin_layout Plain Layout

	pylab.legend()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#       Calcula o número de coelhos depois de num interacções
\end_layout

\begin_layout Plain Layout

#         Para diferentes quantidades iniciais de coelhos
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def Quantidade():
\end_layout

\begin_layout Plain Layout

	for a in A:
\end_layout

\begin_layout Plain Layout

		X_in=[]
\end_layout

\begin_layout Plain Layout

		Y_fin=[]
\end_layout

\begin_layout Plain Layout

		for i in range(N_x):
\end_layout

\begin_layout Plain Layout

			x=n_min+i*1.*(n_max-n_min)/N_x
\end_layout

\begin_layout Plain Layout

			X_in.append(x)
\end_layout

\begin_layout Plain Layout

			for j in range(num):
\end_layout

\begin_layout Plain Layout

				x=inter(a,x)
\end_layout

\begin_layout Plain Layout

			Y_fin.append(x)
\end_layout

\begin_layout Plain Layout

		s="A="+str(a)
\end_layout

\begin_layout Plain Layout

		pylab.plot(X_in,Y_fin,",",label=s)
\end_layout

\begin_layout Plain Layout

	pylab.title("Numero de coelhos no final
\backslash
ndependendo do numero inicial")
\end_layout

\begin_layout Plain Layout

	pylab.xlabel("Coelhos no inicio")
\end_layout

\begin_layout Plain Layout

	pylab.ylabel("Coelhos no fim")
\end_layout

\begin_layout Plain Layout

	pylab.legend()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#      Calcula o número de coelhos depois de num interacções
\end_layout

\begin_layout Plain Layout

#                 Para diferentes constantes
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def Constante():
\end_layout

\begin_layout Plain Layout

	for x in n:
\end_layout

\begin_layout Plain Layout

		X_a=[]
\end_layout

\begin_layout Plain Layout

		Y_fin=[]
\end_layout

\begin_layout Plain Layout

	 	s="numero inicial = "+str(x) 		for i in range(N_A):
\end_layout

\begin_layout Plain Layout

			a=A_min+i*1.*(A_max-A_min)/N_A
\end_layout

\begin_layout Plain Layout

			X_a.append(a)
\end_layout

\begin_layout Plain Layout

			u=x
\end_layout

\begin_layout Plain Layout

			for j in range(num):
\end_layout

\begin_layout Plain Layout

				u=inter(a,u)
\end_layout

\begin_layout Plain Layout

			Y_fin.append(u)
\end_layout

\begin_layout Plain Layout

		pylab.plot(X_a,Y_fin,",",label=s)
\end_layout

\begin_layout Plain Layout

	pylab.title("Numero de coelhos no final
\backslash
nem funcao da constante")
\end_layout

\begin_layout Plain Layout

	pylab.xlabel("Constante")
\end_layout

\begin_layout Plain Layout

	pylab.ylabel("Coelhos no fim")
\end_layout

\begin_layout Plain Layout

	pylab.legend()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#       Calcula o número de coelhos depois de uma interacções
\end_layout

\begin_layout Plain Layout

#                   Para diferentes constantes
\end_layout

\begin_layout Plain Layout

#          É repetida para diferentes quantidades iniciais
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def Ambos():
\end_layout

\begin_layout Plain Layout

	X_a=[]
\end_layout

\begin_layout Plain Layout

	Y_fin=[]
\end_layout

\begin_layout Plain Layout

	for i in range(N_A):
\end_layout

\begin_layout Plain Layout

		a=A_min+(A_max-A_min)*i*1./N_A
\end_layout

\begin_layout Plain Layout

		for k in range(N_x):
\end_layout

\begin_layout Plain Layout

			x=n_min+k*1.*(n_max-n_min)/N_x
\end_layout

\begin_layout Plain Layout

			X_a.append(a)
\end_layout

\begin_layout Plain Layout

			for j in range(num):
\end_layout

\begin_layout Plain Layout

				x=inter(a,x)
\end_layout

\begin_layout Plain Layout

			Y_fin.append(x)
\end_layout

\begin_layout Plain Layout

	pylab.plot(X_a,Y_fin,",")
\end_layout

\begin_layout Plain Layout

	pylab.title("Numero de coelhos no final
\backslash
nem funcao da constante")
\end_layout

\begin_layout Plain Layout

	pylab.xlabel("Constante")
\end_layout

\begin_layout Plain Layout

	pylab.ylabel("Coelhos no fim")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#escolhe que rotina seguir
\end_layout

\begin_layout Plain Layout

if Q==1:
\end_layout

\begin_layout Plain Layout

	Simples()
\end_layout

\begin_layout Plain Layout

elif Q==2:
\end_layout

\begin_layout Plain Layout

	Quantidade()
\end_layout

\begin_layout Plain Layout

elif Q==3:
\end_layout

\begin_layout Plain Layout

	Constante()
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

	Ambos()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#desenha o gráfico
\end_layout

\begin_layout Plain Layout

pylab.savefig("coelhos")
\end_layout

\begin_layout Plain Layout

pylab.show() 
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mapa a 2 dimensões
\end_layout

\begin_layout Standard
Um mapa a 2 dimensões consiste num conjunto de duas variáveis.
 Em cada passo as duas variáveis são actualizadas em simultâneo, vejamos
 alguns exemplos que apresentam caos:
\end_layout

\begin_layout Enumerate
Mapa de Duffing:
\begin_inset Formula \[
\left\{ \begin{array}{rcl}
x_{n+1} & = & y_{n}\\
y_{n+1} & = & -b\ x_{n}+a\ y_{n}-y_{n}^{3}\end{array}\right.\]

\end_inset


\end_layout

\begin_layout Enumerate
Mapa de Hénon:
\begin_inset Formula \[
\left\{ \begin{array}{rcl}
x_{n+1} & = & y_{n}+1-a\ x_{n}^{2}\\
y_{n+1} & = & b\ x_{n}\end{array}\right.\]

\end_inset


\end_layout

\begin_layout Enumerate
Mapa de Tinkerbell:
\begin_inset Formula \[
\left\{ \begin{array}{rcl}
x_{n+1} & = & x_{n}^{2}-y_{n}^{2}+a\ x_{n}+b\ y_{n}\\
y_{n+1} & = & 2\ x_{n}y_{n}+c\ x_{n}+d\ y_{n}\end{array}\right.\]

\end_inset


\end_layout

\begin_layout Standard
Fica a cargo dos alunos mais interessados em programar estes sistemas e
 escolher as informações relevantes a retirar daqui.
\end_layout

\begin_layout Subsection
Funções por ramos
\end_layout

\begin_layout Standard
Uma função por ramos é uma função que tem dois ou mais comportamentos distintos.
 Quando iteradas várias vezes, algumas delas ganham um carácter imprevisível.
\end_layout

\begin_layout Standard
Vejamos alguns exemplos:
\end_layout

\begin_layout Enumerate
Mapa tenda:
\begin_inset Formula \[
x_{n+1}=\left\{ \begin{array}{rcl}
\mu\ x_{n} & se & x_{n}<\frac{1}{2}\\
\mu(1-x_{n}) & se & x_{n}>\frac{1}{2}\end{array}\right.\]

\end_inset


\end_layout

\begin_layout Enumerate
Mapa diático:
\begin_inset Formula \[
x_{n+1}=\left\{ \begin{array}{rcl}
2\ x_{n} & se & x_{n}<\frac{1}{2}\\
2\ x_{n}-1 & se & x_{n}>\frac{1}{2}\end{array}\right.\]

\end_inset


\end_layout

\begin_layout Standard
A programação destes modelos é idêntica às anteriores.
 Sendo assim, fica como exercício aos eventuais leitores que chegaram até
 aqui.
\end_layout

\begin_layout Subsection
Geradores de números aleatórios
\end_layout

\begin_layout Standard
Os computadores actuais são incapazes de produzir números aleatórios, uma
 vez que um computador só utiliza fenómenos deterministicos.
 No entanto, é possível produzir números aparentemente aleatórios, que são
 chamados números pseudo-aleatórios.
 Não é de estranhar que os algorítmos usados sejam caóticos.
 Vejamos alguns exemplos:
\end_layout

\begin_layout Enumerate
Método de Van Neumann:
\end_layout

\begin_deeper
\begin_layout Enumerate
Seja 
\begin_inset Formula $v_{n}$
\end_inset

 um número de 
\begin_inset Formula $n$
\end_inset

 dígitos;
\end_layout

\begin_layout Enumerate
Calculamos 
\begin_inset Formula $m^{2}$
\end_inset

;
\end_layout

\begin_layout Enumerate
E isolamos os 
\begin_inset Formula $n$
\end_inset

 dígitos centrais, temos assim o novo número 
\begin_inset Formula $v_{n+1}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Método de Fibonacci, seja 
\begin_inset Formula $m$
\end_inset

 um primo grande:
\begin_inset Formula \[
x_{n+1}=(x_{n}+x_{n-k})\%m\]

\end_inset

em que 
\begin_inset Formula $k$
\end_inset

 é um número natural.
\end_layout

\begin_layout Enumerate
Método de Lehmner, sejam 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 e 
\begin_inset Formula $c$
\end_inset

 números grandes e primos entre si:
\begin_inset Formula \[
u_{n+1}=(a\ u_{n}+b)\ \%\ c\]

\end_inset


\end_layout

\begin_layout Standard
O aluno interessado não terá dificuldade em programar estes geradores.
\end_layout

\begin_layout Chapter
Cálculo de Órbitas
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

Neste trabalho calculamos a órbita de uma sonda em torno de Júpiter.
 Para isso, simulamos no computador o movimento da sonda e de Júpiter.
 Obviamente que o resultado pode ser facilmente adaptado a outros problemas
 tal como a órbita da lua.
\end_layout

\begin_layout Plain Layout


\backslash
section{Forças}
\end_layout

\begin_layout Plain Layout

Existem na natureza quatro forças fundamentais: a forte, a  fraca, a electromagn
ética e a gravítica.
 Mas no espaço, apenas estamos sujeitos à força gravítica.
 Vejamos a forma da força gravítica entre dois corpos de massa $m_1$ e $m_2$,
 e posição $
\backslash
vec{r}_1$ e $
\backslash
vec{r}_2$ respectivamente:
\end_layout

\begin_layout Plain Layout


\backslash
begin{equation} 
\backslash
label{grav}   
\backslash
vec{F}_{21} = - G 
\backslash
frac{m_1 m_2}{| 
\backslash
vec{r}_{12}|^3} 
\backslash
vec{r}_{12},  
\backslash
end{equation} onde $G$ é a constante de gravitação, $ | 
\backslash
vec{r}_{12}| = | 
\backslash
vec r_1 - 
\backslash
vec r_2 | $ é a distância entre as massas $m_1$ e $m_2$.
 
\end_layout

\begin_layout Plain Layout

É, portanto, uma força atractiva, proporcional a ambas as massas e inversamente
 proporcional ao quadrado da distância entre os dois corpos.
 
\end_layout

\begin_layout Plain Layout

Por outro, a segunda lei de Newton diz-nos que  
\backslash
begin{equation}   
\backslash
vec F = m 
\backslash
vec a, 
\backslash
end{equation} pelo que podemos calcular a aceleração sofrida pela massa
 $m_2$ devido à massa $m_1$: 
\backslash
begin{align} 
\backslash
label{eq:acel}   
\backslash
vec{F}_{21} = - G 
\backslash
frac{m_1 m_2}{| 
\backslash
vec{r}_{12}|^3} 
\backslash
vec{r}_{12} = m_2 
\backslash
, 
\backslash
vec a_2 
\backslash
Leftrightarrow 
\backslash
vec a_2 = - G 
\backslash
frac{m_1}{| 
\backslash
vec{r}_{12}|^3} 
\backslash
vec{r}_{12}.
 
\backslash
end{align}
\end_layout

\begin_layout Plain Layout


\backslash
section{Problema de três corpos}
\end_layout

\begin_layout Plain Layout

Olhemos melhor para o nosso problema.
 Temos três corpos: o Sol (com massa $m_0$ e posição $
\backslash
vec r_0$), Júpiter (com massa $m_1$ e posição $
\backslash
vec r_1$), e uma uma sonda espacial (com massa $m_2$ e posição $
\backslash
vec r_2$).
 
\end_layout

\begin_layout Plain Layout

O Sol é bastante pesado quando comparado com Júpiter ou a sonda.
 Consideramos então que o Sol está fixo, na origem do nosso referencial.
 Poderíamos também desprezar a influência da sonda em Júpiter, no entanto,
 preferimos não o fazer para podermos adaptar facilmente o nosso código
 à órbita de uma lua em torno de um planeta.
\end_layout

\begin_layout Plain Layout

Se inicialmente considerarmos que a sonda está no plano da órbita de Júpiter
 e que a sua velocidade inicial também está nesse plano, verificamos que
 a sonda nunca sai desse plano.
 Visto isso, desprezamos desde o início a direcção perpendicular a esse
 plano.
\end_layout

\begin_layout Plain Layout

Usamos a equação~(
\backslash
ref{grav}) para calcular a aceleração da sonda devido ao Sol e a Júpiter:
 
\backslash
begin{align} 
\backslash
label{eq:acel2}  & 
\backslash
vec F_{20} + 
\backslash
vec{F}_{21} = - G 
\backslash
frac{m_1 m_2}{| 
\backslash
vec{r}_{12}|^3} 
\backslash
vec{r}_{12} - G 
\backslash
frac{m_0 m_2}{| 
\backslash
vec{r}_{02}|^3} 
\backslash
vec{r}_{02} = m_2 
\backslash
, 
\backslash
vec a_2  
\backslash
notag 
\backslash

\backslash
 
\backslash
Leftrightarrow & 
\backslash
vec a_2 = - G 
\backslash
frac{m_1}{| 
\backslash
vec{r}_{12}|^3} 
\backslash
vec{r}_{12}  - G 
\backslash
frac{m_0}{| 
\backslash
vec{r}_{2}|^3} 
\backslash
vec{r}_{2}.
 
\backslash
end{align}
\end_layout

\begin_layout Plain Layout

De igual modo, a aceleração de Júpiter é dado pela fórmula: 
\backslash
begin{align} 
\backslash
label{eq:acel1} 
\backslash
vec a_1 = - G 
\backslash
frac{m_2}{| 
\backslash
vec{r}_{21}|^3} 
\backslash
vec{r}_{21}  - G 
\backslash
frac{m_0}{| 
\backslash
vec{r}_{1}|^3} 
\backslash
vec{r}_{1}.
 
\backslash
end{align}
\end_layout

\begin_layout Plain Layout

Em que a norma de um vector ($
\backslash
vec r= (x,y)$) é dado pela fórmula usual: 
\backslash
begin{equation}   |
\backslash
vec r| = 
\backslash
sqrt{r_x^2+r_y^2}, 
\backslash
end{equation}
\end_layout

\begin_layout Plain Layout


\backslash
section{Método de Euler}
\end_layout

\begin_layout Plain Layout

Estamos interessados em calcular a trajectória da sonda e de Júpiter.
 Sabemos que a variação da posição é dada pela velocidade: 
\backslash
begin{align}   
\backslash
frac{
\backslash
Delta 
\backslash
vec r_1 }{
\backslash
Delta t} & = 
\backslash
vec v_1 
\backslash

\backslash
   
\backslash
frac{
\backslash
Delta 
\backslash
vec r_2 }{
\backslash
Delta t} & = 
\backslash
vec v_2 
\backslash
end{align} e por sua vez, a variação da velocidade é dada pela acelaração
 que depende da posição, como vimos em cima: 
\backslash
begin{align}   
\backslash
frac{
\backslash
Delta 
\backslash
vec v_1 }{
\backslash
Delta t} & = 
\backslash
vec a_1 
\backslash

\backslash
   
\backslash
frac{
\backslash
Delta 
\backslash
vec v_2 }{
\backslash
Delta t} & = 
\backslash
vec a_2.
 
\backslash
end{align} Notem que estas equações são aproximadas.
 Essa aproximação será tanto melhor quanto menor for o intervalo de tempo
 $
\backslash
Delta t$ considerado.
  Vejamos em detalhe uma das equações: 
\backslash
begin{align}   
\backslash
frac{
\backslash
Delta r_x }{
\backslash
Delta t} & = v_x 
\backslash

\backslash
   
\backslash
Delta r_x & = v_x 
\backslash
Delta t, 
\backslash
end{align} ou seja,  
\backslash
begin{equation}   r_x(t+
\backslash
Delta t) =r_x(t)+ v_x 
\backslash
Delta t  
\backslash
end{equation}
\end_layout

\begin_layout Plain Layout

O método de Euler é baseado neste resultado.
 Sabendo as posições e as velocidades iniciais, calculamos o valor destas
 um instante $
\backslash
Delta t$ depois.
 Temos agora novas posições e velocidades, e podemos calcular o próximo
 passo.
 E assim, sucessivamente.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
O código em Python
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# coding: utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

from __future__ import division
\end_layout

\begin_layout Plain Layout

from math import *
\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

from visual import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UD=7.78412027E+7		   # distância de referência 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

r2=7.78412027E+8/UD                # raio (médio) da órbita de Júpiter em
 km 
\end_layout

\begin_layout Plain Layout

raio_jup=6.9173e4/UD               # raio de Júpiter em km 
\end_layout

\begin_layout Plain Layout

raio_sol=6.95500e5/UD              # raio do Sol em km
\end_layout

\begin_layout Plain Layout

massa_jup=1.8988E+27               # massa de Júpiter 
\end_layout

\begin_layout Plain Layout

massa_sol=1.988435E+30             # massa do Sol  
\end_layout

\begin_layout Plain Layout

massa=2.e3                         # massa da sonda em kg
\end_layout

\begin_layout Plain Layout

G=(6.67E-20)*3600**2/(UD**3)       # constante de gravitação universal em
 kg^-1 UD^3 h^-2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# condições iniciais, 
\end_layout

\begin_layout Plain Layout

# o vector 'u' contém as posições e velocidades iniciais dos dois corpos:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

u=8*[0.] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

u[0]=7.57e8/UD                     # coordenada x inicial da sonda 
\end_layout

\begin_layout Plain Layout

u[1]=4.493e6/UD                    # coordenada y inicial da sonda
\end_layout

\begin_layout Plain Layout

vel_i=50650./UD                    # velocidade inicial da sonda 
\end_layout

\begin_layout Plain Layout

theta_i=70.
                        # ângulo inicial 
\end_layout

\begin_layout Plain Layout

u[2]=vel_i*cos(theta_i*pi/180.)    # componente x da velicidade da sonda
 
\end_layout

\begin_layout Plain Layout

u[3]=vel_i*sin(theta_i*pi/180.)    # componente y da velocidade da sonda
   
\end_layout

\begin_layout Plain Layout

omega=sqrt(G*massa_sol)/pow(r2,1.5)# velocidade angular de Jupiter em rad/hora
\end_layout

\begin_layout Plain Layout

u[4]=r2                            # coordenada x inicial de Júpiter 
\end_layout

\begin_layout Plain Layout

u[5]=0.
                            # coordenada y inicial de Júpiter
\end_layout

\begin_layout Plain Layout

u[6]=0.
                            # componente x da velicidade de Júpiter 
\end_layout

\begin_layout Plain Layout

u[7]=1.*omega * r2                 # componente y da velicidade de Júpiter
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Calcula a variação das velocidades e das posições de Júpiter e do satélite
\end_layout

\begin_layout Plain Layout

def variacao(u):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    v=8*[0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Posição da sonda
\end_layout

\begin_layout Plain Layout

    v[0]=u[2]     v[1]=u[3]
\end_layout

\begin_layout Plain Layout

	# Velocidade da sonda
\end_layout

\begin_layout Plain Layout

    v[2]=-G*massa_sol*u[0]/pow(u[0]**2+u[1]**2,1.5)
\backslash

\end_layout

\begin_layout Plain Layout

         -G*massa_jup*(u[0]-u[4])/pow(u[0]**2+u[1]**2+
\backslash

\end_layout

\begin_layout Plain Layout

          u[4]**2+u[5]**2-2*(u[0]*u[4]+u[1]*u[5]),1.5)
\end_layout

\begin_layout Plain Layout

    v[3]=-G*massa_sol*u[1]/pow(u[0]**2+u[1]**2,1.5)
\backslash

\end_layout

\begin_layout Plain Layout

         -G*massa_jup*(u[1]-u[5])/pow(u[0]**2+u[1]**2+
\backslash

\end_layout

\begin_layout Plain Layout

           u[4]**2+u[5]**2-2*(u[0]*u[4]+u[1]*u[5]),1.5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Posição de Júpiter
\end_layout

\begin_layout Plain Layout

    v[4]=u[6]
\end_layout

\begin_layout Plain Layout

    v[5]=u[7]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	# Velocidade de Júpiter
\end_layout

\begin_layout Plain Layout

    v[6]=-G*massa_sol*u[4]/pow(u[4]**2+u[5]**2,1.5)
\backslash

\end_layout

\begin_layout Plain Layout

         +G*massa*(u[0]-u[4])/pow(u[0]**2+u[1]**2+
\backslash

\end_layout

\begin_layout Plain Layout

            u[4]**2+u[5]**2-2*(u[0]*u[4]+u[1]*u[5]),1.5)
\end_layout

\begin_layout Plain Layout

    v[7]=-G*massa_sol*u[5]/pow(u[4]**2+u[5]**2,1.5)
\backslash

\end_layout

\begin_layout Plain Layout

         +G*massa*(u[1]-u[5])/pow(u[0]**2+u[1]**2+
\backslash

\end_layout

\begin_layout Plain Layout

            u[4]**2+u[5]**2-2*(u[0]*u[4]+u[1]*u[5]),1.5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return v
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Método de Euler
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def euler(u,dt):
\end_layout

\begin_layout Plain Layout

    v=variacao(u)[:]
\end_layout

\begin_layout Plain Layout

    # v é a variação de u
\end_layout

\begin_layout Plain Layout

    for i in range(8):
\end_layout

\begin_layout Plain Layout

        u[i]+=v[i]*dt
\end_layout

\begin_layout Plain Layout

    return u
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Escreve as trajectórias para uma lista traj
\end_layout

\begin_layout Plain Layout

def trajectoria():
\end_layout

\begin_layout Plain Layout

    traj[0].append(u[0])
\end_layout

\begin_layout Plain Layout

    traj[1].append(u[1])
\end_layout

\begin_layout Plain Layout

    traj[2].append(u[4])
\end_layout

\begin_layout Plain Layout

    traj[3].append(u[5])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Animação:
\end_layout

\begin_layout Plain Layout

def anim(t):
\end_layout

\begin_layout Plain Layout

    # No início temos que criar os objectos
\end_layout

\begin_layout Plain Layout

    if t==0:
\end_layout

\begin_layout Plain Layout

         global jupiter, jupiter2           # usamos "global" para que póssamos
 usar
\end_layout

\begin_layout Plain Layout

         global sonda, sonda2               # estes objectos das próximas
 vezes que
\end_layout

\begin_layout Plain Layout

         global ref_sol, ref_jup            # corrermos esta função 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

         lado=400
\end_layout

\begin_layout Plain Layout

         d0 = r2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 # O display cria uma janela que chamaremos ref_sol.
 A largura e a altura são igual a lado.
     
\end_layout

\begin_layout Plain Layout

 # O centro é (0,0,0).'range' define a escala da janela.
 Desligamos o 'autoscale'     
\end_layout

\begin_layout Plain Layout

 # e 'exit = 0' evita que o programa pare ao fechar manualmente a janela.
\end_layout

\begin_layout Plain Layout

         ref_sol=display(title = 'Orbita no referencial do Sol',
\end_layout

\begin_layout Plain Layout

                        x=0, y=0, width=lado, height=lado,center=(0,0,0),
\end_layout

\begin_layout Plain Layout

                         range=(1.2*d0,1.2*d0,1.2*d0),autoscale=0, exit=0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # definimos 'jupiter' como uma esfera na janela 'ref_sol'.
\end_layout

\begin_layout Plain Layout

         jupiter=sphere(display=ref_sol, pos=(u[4],u[5],0),
\end_layout

\begin_layout Plain Layout

                        radius=raio_jup, color=color.orange)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # para ver o rasto (trail) de 'jupiter' usamos:
\end_layout

\begin_layout Plain Layout

        jupiter.trail=curve(color=jupiter.color)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # definimos uma curva chamada 'sonda':
\end_layout

\begin_layout Plain Layout

        sonda=curve(display=ref_sol, color=color.green)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # definimos uma outra esfera chamada 'sun':
\end_layout

\begin_layout Plain Layout

        sun=sphere(display=ref_sol, pos=(0,0,0),
\end_layout

\begin_layout Plain Layout

                   radius=0.05*r2, color=color.red)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # criamos uma segunda janela, para uma animação no referencial de Júpiter:
\end_layout

\begin_layout Plain Layout

        ref_jup=display(title = 'Orbita no referencial de Jupiter',
\end_layout

\begin_layout Plain Layout

                         x=lado, y=lado, height=lado, width=lado, uniform=1,
\end_layout

\begin_layout Plain Layout

                        autoscale=1, autocenter=1, exitr=0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # criamos uma esfera de nome sonda2 com o respectivo traço
\end_layout

\begin_layout Plain Layout

        sonda2=sphere(display=ref_jup, pos=(u[0]-u[4],u[1]-u[5],0), 
\end_layout

\begin_layout Plain Layout

                      radius=0.1/UD,color=color.green)
\end_layout

\begin_layout Plain Layout

        sonda2.trail=curve(color=sonda2.color)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # criamos uma esfera chamada jupiter2 com uma etiqueta
\end_layout

\begin_layout Plain Layout

       jupiter2=sphere(display=ref_jup, pos=(0,0,0), radius=raio_jup,
\end_layout

\begin_layout Plain Layout

                         color=color.orange)
\end_layout

\begin_layout Plain Layout

       label(pos=jupiter2.pos, text='Jupiter')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # se t maior que zero, actualizamos as posições dos objectos:
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        rate(10000)   # limitamos a frequência de actualização a 10000 por
 segundo.
\end_layout

\begin_layout Plain Layout

        jupiter.pos=(u[4],u[5],0)                # actualizamos a posição
 de jupiter
\end_layout

\begin_layout Plain Layout

        jupiter.trail.append(pos=jupiter.pos)     # e também o seu rasto
\end_layout

\begin_layout Plain Layout

        sonda.append(pos=(u[0],u[1],0))           # actualizamos a posição
 de sonda
\end_layout

\begin_layout Plain Layout

        jupiter2.pos=(0,0,0)                      # actualizamos a posição
 de jupiter2
\end_layout

\begin_layout Plain Layout

        sonda2.pos=(u[0]-u[4],u[1]-u[5],0)        # actualizamos a posição
 de sonda2
\end_layout

\begin_layout Plain Layout

        sonda2.trail.append(pos=sonda2.pos)       # e o seu traço
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# inicio programa
\end_layout

\begin_layout Plain Layout

# decide se apresenta ou não as animações
\end_layout

\begin_layout Plain Layout

choice = raw_input("Queres ver as animações [S/n]?")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if choice=='n' or choice=='N':
\end_layout

\begin_layout Plain Layout

    choice=0
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    choice=1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

t=0.0                                  # tempo inicial
\end_layout

\begin_layout Plain Layout

tmax=5000.0                            # tempo de simulação
\end_layout

\begin_layout Plain Layout

passo = 0.5                            # passo de integração
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

delta = 100                            # intervalo de tempo entre cada registo
 de dados
\end_layout

\begin_layout Plain Layout

traj=[[],[],[],[]]                     # lista com a trajectória da sonda
 e de Jupiter
\end_layout

\begin_layout Plain Layout

                                      # a ordem é: [x_sonda, y_sonda, x_jupiter,
 y_jupiter] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

trajectoria()                          # primeiro ponto da trajectória
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if choice == 1:
\end_layout

\begin_layout Plain Layout

    anim(t)
\end_layout

\begin_layout Plain Layout

t_traj=delta                           # tempo do próximo ponto da trajectória
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while t<tmax:
\end_layout

\begin_layout Plain Layout

    u=euler(u,passo)
\end_layout

\begin_layout Plain Layout

    t+=passo
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # a animação:
\end_layout

\begin_layout Plain Layout

    if choice == 1:
\end_layout

\begin_layout Plain Layout

        anim(t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if t>=t_traj:          # escreve um ponto da trajectória quando atinge
 t_traj
\end_layout

\begin_layout Plain Layout

        print 't=',t,'/',tmax
\end_layout

\begin_layout Plain Layout

        trajectoria()
\end_layout

\begin_layout Plain Layout

        t_traj+=delta
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if u[0]**2+u[1]**2<raio_sol**2:    # testa se caiu ao sol
\end_layout

\begin_layout Plain Layout

        print "A sonda caiu no Sol"
\end_layout

\begin_layout Plain Layout

        break
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (u[0]-u[4])**2+(u[1]-u[5])**2<raio_jup**2:   # testa se caiu a Júpiter
\end_layout

\begin_layout Plain Layout

        print "A sonda caiu em Júpiter"
\end_layout

\begin_layout Plain Layout

        break
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# depois do ciclo escreve um ultimo ponto  
\end_layout

\begin_layout Plain Layout

print 't = ',t,'/',tmax trajectoria()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Desenha a orbita
\end_layout

\begin_layout Plain Layout

pylab.title("Orbitas!") 
\end_layout

\begin_layout Plain Layout

pylab.xlabel("x") 
\end_layout

\begin_layout Plain Layout

pylab.ylabel("y")
\end_layout

\begin_layout Plain Layout

pylab.plot(traj[0],traj[1], label = 'Sonda') 
\end_layout

\begin_layout Plain Layout

pylab.plot(traj[2],traj[3], label = 'Jupiter')
\end_layout

\begin_layout Plain Layout

pylab.legend() 
\end_layout

\begin_layout Plain Layout

# pylab.savefig("orbita.png")
\end_layout

\begin_layout Plain Layout

pylab.show()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
Bibliotecas úteis e exemplos 
\end_layout

\begin_layout Standard
No capítulo 3 já foram usadas bibliotecas para poder usar funções matemáticas
 ou fazer gráficos.
 Neste capítulo vamos mostrar vários exemplos de código que usam bibliotecas
 que podem ser úteis em várias situações.
 
\end_layout

\begin_layout Subsection*
1) Grafico animado (pylab/matplotlib)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pylab
\end_layout

\begin_layout Plain Layout

import random
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pede ao pylab para entrar no modo interactivo (ion = interactive on) 
\end_layout

\begin_layout Plain Layout

# Assim podemos alterar os gráficos em tempo real, dentro do nosso programa
 
\end_layout

\begin_layout Plain Layout

pylab.ion()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria as listas que representam a nossa trajectória x,y 
\end_layout

\begin_layout Plain Layout

# inicialmente estamos no ponto (0,0) 
\end_layout

\begin_layout Plain Layout

x = [0] 
\end_layout

\begin_layout Plain Layout

y = [0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Desenha um linha com a trajectória x,y 
\end_layout

\begin_layout Plain Layout

#  azul (b), com pontos (o) e linhas (-), semitransparente (alpha=0.5) 
\end_layout

\begin_layout Plain Layout

line, = pylab.plot(x,y,'bo-',alpha='0.5')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Adiciona um ponto novo à trajectória e desenha-a novamente no ecrã 100
 vezes 
\end_layout

\begin_layout Plain Layout

for i in xrange(100):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Adiciona valores as listas com os dados de x e y da nossa trajectória
\end_layout

\begin_layout Plain Layout

    # segundo um passeio aleatorio
\end_layout

\begin_layout Plain Layout

    p = random.random()*4
\end_layout

\begin_layout Plain Layout

    if(p < 1):
\end_layout

\begin_layout Plain Layout

         x.append(x[-1]+1)
\end_layout

\begin_layout Plain Layout

        y.append(y[-1])
\end_layout

\begin_layout Plain Layout

    elif(p < 2):
\end_layout

\begin_layout Plain Layout

         x.append(x[-1]-1)
\end_layout

\begin_layout Plain Layout

        y.append(y[-1])
\end_layout

\begin_layout Plain Layout

    elif(p < 3):
\end_layout

\begin_layout Plain Layout

         x.append(x[-1])
\end_layout

\begin_layout Plain Layout

        y.append(y[-1]-1)
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        x.append(x[-1])
\end_layout

\begin_layout Plain Layout

        y.append(y[-1]+1)
\end_layout

\begin_layout Plain Layout

      # Muda os valores de x e y da linha que já desenhamos
\end_layout

\begin_layout Plain Layout

    # Notem que podem ter comprimentos diferentes do gráfico original
\end_layout

\begin_layout Plain Layout

    line.set_data(x,y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Define os limites do gráfico novamente.
\end_layout

\begin_layout Plain Layout

     # Se não fizessemos isto ele usaria os limites do primeiro gráfico
\end_layout

\begin_layout Plain Layout

    pylab.xlim(-20,20)
\end_layout

\begin_layout Plain Layout

    pylab.ylim(-20,20)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Desenha o gráfico outra vez
\end_layout

\begin_layout Plain Layout

    pylab.draw()                        
\end_layout

\begin_layout Plain Layout

                     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
2) Vários gráficos animados na mesma janela (pylab/matplotlib)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pylab 
\end_layout

\begin_layout Plain Layout

import random 
\end_layout

\begin_layout Plain Layout

import numpy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Rotina que retorna dois vectores com um passeio aleatório de comprimento
 'tamanho', que começa no ponto (x0,y0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def passeio_aleatorio(x0,y0,tamanho):
\end_layout

\begin_layout Plain Layout

    #Cria 2 vectores, cada um com comprimento 'tamanho'
\end_layout

\begin_layout Plain Layout

    x = numpy.zeros(tamanho)
\end_layout

\begin_layout Plain Layout

    y = numpy.zeros(tamanho)
\end_layout

\begin_layout Plain Layout

    #O ponto inicial é (x0,y0)
\end_layout

\begin_layout Plain Layout

    x[0] = x0
\end_layout

\begin_layout Plain Layout

    y[0] = y0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for i in xrange(1,tamanho):
\end_layout

\begin_layout Plain Layout

        p = random.random()*4
\end_layout

\begin_layout Plain Layout

        if(p < 1):
\end_layout

\begin_layout Plain Layout

             x[i] = x[i-1]+1
\end_layout

\begin_layout Plain Layout

            y[i] = y[i-1]
\end_layout

\begin_layout Plain Layout

        elif(p < 2):
\end_layout

\begin_layout Plain Layout

            x[i] = x[i-1]-1
\end_layout

\begin_layout Plain Layout

            y[i] = y[i-1]
\end_layout

\begin_layout Plain Layout

        elif(p < 3):
\end_layout

\begin_layout Plain Layout

            x[i] = x[i-1]
\end_layout

\begin_layout Plain Layout

            y[i] = y[i-1]-1
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            x[i] = x[i-1]
\end_layout

\begin_layout Plain Layout

            y[i] = y[i-1]+1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return x,y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# # # Programa principal # #
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Dados do programa 
\end_layout

\begin_layout Plain Layout

num_iteracoes = 100 
\end_layout

\begin_layout Plain Layout

tamanho = 32
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pede ao pylab para entrar no modo interactivo (ion = interactive on) 
\end_layout

\begin_layout Plain Layout

# Assim podemos alterar os gráficos em tempo real, dentro do nosso programa
 
\end_layout

\begin_layout Plain Layout

pylab.ion()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria a janela com 9x9 polegadas, com cor branca (w=white) 
\end_layout

\begin_layout Plain Layout

pylab.figure(0,figsize=(9,9),facecolor='w')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Escreve o título do gráfico pylab.suptitle('Demonstracao passeio aleatorio')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Reserva espaco para o passeio aleatorio num vector 
\end_layout

\begin_layout Plain Layout

passeio_x = numpy.zeros((num_iteracoes*tamanho))
\end_layout

\begin_layout Plain Layout

passeio_y = numpy.zeros((num_iteracoes*tamanho))
\end_layout

\begin_layout Plain Layout

#preenche os primeiros 'tamanho' pontos dos vectores com um passeio aleatorio
 que começa em (0,0)
\end_layout

\begin_layout Plain Layout

passeio_x[0:tamanho],passeio_y[0:tamanho] = passeio_aleatorio(0,0,tamanho)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Grafico 1: 1 Passeio aleatório (o primeiro de uma matrix de 2x2)
\end_layout

\begin_layout Plain Layout

passeio_subplot = pylab.subplot(221)
\end_layout

\begin_layout Plain Layout

passeio_subplot.set_title('Passeio aleatorio (1 particula)') 
\end_layout

\begin_layout Plain Layout

passeio_line, = pylab.plot(passeio_x[0:tamanho],passeio_y[0:tamanho])
\end_layout

\begin_layout Plain Layout

#Calcula o desvio quadrático da trajectoria 
\end_layout

\begin_layout Plain Layout

r_quadrado = passeio_x**2+passeio_y**2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Grafico 2: Desvio Quadrático Médio para uma particula (o segundo de uma
 matrix de 2x2)
\end_layout

\begin_layout Plain Layout

desvio_subplot = pylab.subplot(222)
\end_layout

\begin_layout Plain Layout

 desvio_subplot.set_title('Desvio Quadratico Medio (1 particula)')
\end_layout

\begin_layout Plain Layout

desvio_line, = pylab.plot(r_quadrado)
\end_layout

\begin_layout Plain Layout

desvio_subplot.set_xlim(0,num_iteracoes*tamanho)
\end_layout

\begin_layout Plain Layout

desvio_subplot.set_ylim(0,10000)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Reserva espaço para as trajectorias de 10 particulas em vectores (num_iteracoe
s*tamanho,10)
\end_layout

\begin_layout Plain Layout

passeios_10_x = numpy.zeros((num_iteracoes*tamanho,10))
\end_layout

\begin_layout Plain Layout

passeios_10_y = numpy.zeros((num_iteracoes*tamanho,10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Preenche os inicios dos vectores com vários passeios aleatórios
\end_layout

\begin_layout Plain Layout

for i in xrange(10):
\end_layout

\begin_layout Plain Layout

    passeios_10_x[0:tamanho,i],passeios_10_y[0:tamanho,i] = passeio_aleatorio(0,
0,tamanho)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Grafico 3: passeios aleatorios de 10 particulas (o terceiro de uma matrix
 de 2x2)
\end_layout

\begin_layout Plain Layout

passeios_10_subplot = pylab.subplot(223)
\end_layout

\begin_layout Plain Layout

 passeios_10_subplot.set_title('Passeios Aleatorios (10 particulas)')
\end_layout

\begin_layout Plain Layout

passeios_10_lines = pylab.plot(passeios_10_x[0:tamanho,:],passeios_10_y[0:tamanho
,:])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Calcula os desvios quadráticos médios, fazendo a soma dos quadrados das
 matrizes e
\end_layout

\begin_layout Plain Layout

#     somando ao longo do eixo das partículas.
 (eixo das trajectorias = 0, eixo das particulas = 1)
\end_layout

\begin_layout Plain Layout

 r_quadrado10 = numpy.sum(passeios_10_x**2+passeios_10_y**2,axis=1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Grafico 4:Desvio quadratico medio para 10 particulas (o quarto de uma matrix
 de 2x2)
\end_layout

\begin_layout Plain Layout

desvios10_subplot = pylab.subplot(224)
\end_layout

\begin_layout Plain Layout

desvios10_subplot.set_title('Desvio Quadratico Medio (10 particulas)')
\end_layout

\begin_layout Plain Layout

desvios10_line, = pylab.plot(r_quadrado10)
\end_layout

\begin_layout Plain Layout

desvios10_subplot.set_xlim(0,num_iteracoes*tamanho)
\end_layout

\begin_layout Plain Layout

desvios10_subplot.set_ylim(0,50000)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Para cada iteracção 
\end_layout

\begin_layout Plain Layout

for i in xrange(num_iteracoes-1):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #Adiciona mais pontos ao vector do passeio aleatório
\end_layout

\begin_layout Plain Layout

    x,y = passeio_aleatorio(passeio_x[(i+1)*tamanho-1],passeio_y[(i+1)*tamanho-1
],tamanho)
\end_layout

\begin_layout Plain Layout

    passeio_x[(i+1)*tamanho:(i+2)*tamanho] = x
\end_layout

\begin_layout Plain Layout

    passeio_y[(i+1)*tamanho:(i+2)*tamanho] = y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #Actualiza o grafico do passeio aleatorio
\end_layout

\begin_layout Plain Layout

    passeio_line.set_data(passeio_x[:(i+2)*tamanho],passeio_y[:(i+2)*tamanho])
\end_layout

\begin_layout Plain Layout

     passeio_subplot.set_xlim(-100,100)
\end_layout

\begin_layout Plain Layout

    passeio_subplot.set_ylim(-100,100)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #Recalcula o desvio quadratico médio de 1 particula e actualiza os dados
 do grafico
\end_layout

\begin_layout Plain Layout

    r_quadrado = passeio_x**2+passeio_y**2
\end_layout

\begin_layout Plain Layout

    desvio_line.set_ydata(r_quadrado)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #Adiciona mais pontos às várias trajectorias dos passeios aleatorios
 de 10 particulas e actualiza os dados do graficos
\end_layout

\begin_layout Plain Layout

    for j in xrange(10):
\end_layout

\begin_layout Plain Layout

        x,y = passeio_aleatorio(passeios_10_x[(i+1)*tamanho-1,j],passeios_10_y[(
i+1)*tamanho-1,j],tamanho)
\end_layout

\begin_layout Plain Layout

        passeios_10_x[(i+1)*tamanho:(i+2)*tamanho,j] = x
\end_layout

\begin_layout Plain Layout

        passeios_10_y[(i+1)*tamanho:(i+2)*tamanho,j] = y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        passeios_10_lines[j].set_data(passeios_10_x[:(i+2)*tamanho,j],passeios_10
_y[:(i+2)*tamanho,j])
\end_layout

\begin_layout Plain Layout

    passeios_10_subplot.set_xlim(-100,100)
\end_layout

\begin_layout Plain Layout

    passeios_10_subplot.set_ylim(-100,100)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #Recalcula o desvios quadratico médio dos passeios das 10 partículas
\end_layout

\begin_layout Plain Layout

    r_quadrado10 = numpy.sum(passeios_10_x**2+passeios_10_y**2,axis=1)
\end_layout

\begin_layout Plain Layout

    desvios10_line.set_ydata(r_quadrado10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Desenha o gráfico outra vez
\end_layout

\begin_layout Plain Layout

    pylab.draw()    
\end_layout

\begin_layout Plain Layout

         
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
3) Gráficos z=f(x,y) e o conjunto de mandelbrot (pylab/matplotlib)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pylab 
\end_layout

\begin_layout Plain Layout

import numpy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Rotina que retorna uma matrix (w,h) com o conjunto de mandelbrot 
\end_layout

\begin_layout Plain Layout

#   uma boa explicação do que é em http://en.wikipedia.org/wiki/Mandelbrot_set
 def mandelbrot( h,w,x0,y0,dx,dy, maxit=50 ):         # codigo retirado
 de http://www.scipy.org/Tentative_NumPy_Tutorial/Mandelbrot_Set_Example
\end_layout

\begin_layout Plain Layout

        y,x = numpy.ogrid[ (y0-dy):(y0+dy):w*1j ,(x0-dx):x0+dx:h*1j]
\end_layout

\begin_layout Plain Layout

        c = x+y*1j
\end_layout

\begin_layout Plain Layout

        z = c
\end_layout

\begin_layout Plain Layout

        divtime = maxit + numpy.zeros(z.shape, dtype=int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for i in xrange(maxit):
\end_layout

\begin_layout Plain Layout

                z  = z**2 + c                 diverge = z*numpy.conj(z) >
 2**2            # who is diverging
\end_layout

\begin_layout Plain Layout

                div_now = diverge & (divtime==maxit)  # who is diverging
 now
\end_layout

\begin_layout Plain Layout

                divtime[div_now] = i                 # note when
\end_layout

\begin_layout Plain Layout

                z[diverge] = 2                       # avoid diverging too
 much
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        return divtime
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

# Programa principal 
\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pede ao pylab para entrar no modo interactivo (ion = interactive on) 
\end_layout

\begin_layout Plain Layout

# Assim podemos alterar os gráficos em tempo real, dentro do nosso programa
\end_layout

\begin_layout Plain Layout

pylab.ion()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Título pylab.title('Conjunto de Mandelbrot')
\end_layout

\begin_layout Plain Layout

# Ponto à volta do qual vamos fazer zoom 
\end_layout

\begin_layout Plain Layout

x0, y0 = -0.1528,1.0397
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mandelbrot_image = pylab.imshow(mandelbrot(64,64,-0.5,0,2,2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for i in xrange(100):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #conjunto de mandelbrot
\end_layout

\begin_layout Plain Layout

    dx = 2*numpy.exp(-i*0.1)
\end_layout

\begin_layout Plain Layout

    dy = 2*numpy.exp(-i*0.1)
\end_layout

\begin_layout Plain Layout

    mandelbrot_image.set_data(mandelbrot(64,64,x0,y0,dx,dy))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Desenha o gráfico outra vez     
\end_layout

\begin_layout Plain Layout

pylab.draw()    
\end_layout

\begin_layout Plain Layout

         
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
4) Como desenhar imagens e animações no ecrã (pygame)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import random
\end_layout

\begin_layout Plain Layout

import math
\end_layout

\begin_layout Plain Layout

import pygame
\end_layout

\begin_layout Plain Layout

from pygame.locals import * #para podermos usar o QUIT, KEYDOWN e K_ESCAPE
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

# Documentação do PyGame - http://pygame.org/docs/index.html
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Inicializa o PyGame
\end_layout

\begin_layout Plain Layout

pygame.init()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria uma variável 'screen' que representa a janela, na qual podemos desenhar
\end_layout

\begin_layout Plain Layout

# Tem 800x600 pixeis
\end_layout

\begin_layout Plain Layout

screen = pygame.display.set_mode((800, 600))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# O título da janela
\end_layout

\begin_layout Plain Layout

pygame.display.set_caption('Satélites')
\end_layout

\begin_layout Plain Layout

# Faz load de uma imagem da terra, para a podermos desenhar
\end_layout

\begin_layout Plain Layout

# um ficheiro adequado: http://www.windypundit.com/archives/2005/images/20050528-G
oogleEarthScreen2.jpg
\end_layout

\begin_layout Plain Layout

 imagem_terra = pygame.image.load('terra.jpg')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# desenha a terra no centro da janela
\end_layout

\begin_layout Plain Layout

screen.blit(imagem_terra, (400-imagem_terra.get_width()/2.,300-imagem_terra.get_heig
ht()/2.))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria N satélites para orbitar a terra
\end_layout

\begin_layout Plain Layout

# cria 4 listas: 2 para a posição (x e y) e 2 para a velocidade (vx e vy)
\end_layout

\begin_layout Plain Layout

N = 10
\end_layout

\begin_layout Plain Layout

satelite_x  = [random.random()*800  for i in xrange(25)]
\end_layout

\begin_layout Plain Layout

 #http://www.network-theory.co.uk/docs/pytut/ListComprehensions.html
\end_layout

\begin_layout Plain Layout

satelite_y  = [random.random()*600  for i in xrange(25)]
\end_layout

\begin_layout Plain Layout

satelite_vx = [random.random()*10-5 for i in xrange(25)]
\end_layout

\begin_layout Plain Layout

satelite_vy = [random.random()*10-5 for i in xrange(25)]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria uma lista de N cores aleatórias
\end_layout

\begin_layout Plain Layout

# cada cor sao 3 valores entre 0 e 255, segundo o sistema RGB http://en.wikipedia.
org/wiki/RGB
\end_layout

\begin_layout Plain Layout

satelite_cor = [(random.randrange(10,250),random.randrange(10,250),random.randrange
(10,250)) for i in xrange(25)]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Guarda o tempo em milisegundos, para podermos apagar o ecrã de 20 em 20
 segundos
\end_layout

\begin_layout Plain Layout

ultimo_instante = pygame.time.get_ticks()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Corre em ciclo enquanto o utilizador não tentar sair
\end_layout

\begin_layout Plain Layout

while 1:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #vamos calcular a energia total em cada ciclo.
 é suposto ficar constante
\end_layout

\begin_layout Plain Layout

    #inicia como zero
\end_layout

\begin_layout Plain Layout

    energia_total = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Actualiza as posições dos satélites
\end_layout

\begin_layout Plain Layout

    for i in xrange(N):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        #calcula a aceleração devido à força gravítica         dx = float(sateli
te_x[i])-400.
\end_layout

\begin_layout Plain Layout

        dy = float(satelite_y[i])-300.
\end_layout

\begin_layout Plain Layout

        r = math.sqrt(dx**2+dy**2) #distância ao centro da terra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        constante = 2500
\end_layout

\begin_layout Plain Layout

  #valor arbitrário, neste programa não precisamos de valores realistas
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        #aceleracao = 1./r**2, mas decompondo nas duas componentes ax,ay
 temos:
\end_layout

\begin_layout Plain Layout

        ax = -constante*dx/r**3
\end_layout

\begin_layout Plain Layout

        ay = -constante*dy/r**3
\end_layout

\begin_layout Plain Layout

                  dt = 0.25
\end_layout

\begin_layout Plain Layout

#valor arbitrário, neste programa não precisamos de valores realistas.
\end_layout

\begin_layout Plain Layout

         # quanto mais pequeno este valor fôr, mais estáveis serão os resultados
\end_layout

\begin_layout Plain Layout

         # (isto é, há menos satélites a sair disparados sem motivo quando
 se aproximam muito da terra)
\end_layout

\begin_layout Plain Layout

        # integração utilizando o método de euler-cromer - http://wiki.vdrift.net/
Numerical_Integration#Newton-Stormer-Verlet_.28NSV.29_.2F_Symplectic_Euler_.2F_Euler.
E2.80.93Cromer_algorithm
\end_layout

\begin_layout Plain Layout

        satelite_vx[i] += dt*ax
\end_layout

\begin_layout Plain Layout

             satelite_vy[i] += dt*ay 
\end_layout

\begin_layout Plain Layout

        satelite_x[i] += dt*satelite_vx[i]
\end_layout

\begin_layout Plain Layout

        satelite_y[i] += dt*satelite_vy[i]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Se o satelite se afastar muito, volta a colocá-lo no ecrã com
 velocidade aleatoria
\end_layout

\begin_layout Plain Layout

        if(r > 1000):
\end_layout

\begin_layout Plain Layout

             satelite_x[i]  = random.random()*800
\end_layout

\begin_layout Plain Layout

              satelite_y[i]  = random.random()*600
\end_layout

\begin_layout Plain Layout

            satelite_vx[i] = random.random()*10-5
\end_layout

\begin_layout Plain Layout

             satelite_vy[i] = random.random()*10-5
\end_layout

\begin_layout Plain Layout

            print 'Um novo satélite foi gerado.
 A energia total será diferente'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Calcula a energia do satélite e adiciona à total
\end_layout

\begin_layout Plain Layout

        massa  = 1
\end_layout

\begin_layout Plain Layout

        energia_satelite = 1./2.* massa * (satelite_vx[i]**2 + satelite_vy[i]**2)
 - constante*massa/r
\end_layout

\begin_layout Plain Layout

        energia_total += energia_satelite
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    print 'Energia total = ',energia_total
\end_layout

\begin_layout Plain Layout

    # Escreve a energia total no título
\end_layout

\begin_layout Plain Layout

    #pygame.display.set_caption('Satélites - energia total = %f'%energia_total)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # desenha os N satélites como circunferências  na janela screen
\end_layout

\begin_layout Plain Layout

    # na posição (satelite_x[i],satelite_y[i]), com raio 2 e espessura da
 linha 1
\end_layout

\begin_layout Plain Layout

    for i in xrange(N):
\end_layout

\begin_layout Plain Layout

        pygame.draw.circle(screen, satelite_cor[i], (int(satelite_x[i]),int(sateli
te_y[i])), 2,1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Pergunta ao PyGame se o utilizador tentou interagir com a janela e
 percorre todos os eventos que aconteceram dessa interacção
\end_layout

\begin_layout Plain Layout

    for event in pygame.event.get():
\end_layout

\begin_layout Plain Layout

        if event.type == QUIT:  #Se ele tentou fechar a janela
\end_layout

\begin_layout Plain Layout

            quit()
\end_layout

\begin_layout Plain Layout

        elif event.type == KEYDOWN and event.key == K_ESCAPE:
\end_layout

\begin_layout Plain Layout

#Se carregou numa tecla e essa tecla era o Escape
\end_layout

\begin_layout Plain Layout

            quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    pygame.display.flip() #actualiza o conteúdo da janela
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Se ja passaram 20 segundos, limpa a janela
\end_layout

\begin_layout Plain Layout

    este_instante = pygame.time.get_ticks()
\end_layout

\begin_layout Plain Layout

    if(este_instante - ultimo_instante > 20000):
\end_layout

\begin_layout Plain Layout

        #preenche a janela de preto
\end_layout

\begin_layout Plain Layout

        screen.fill((0,0,0))
\end_layout

\begin_layout Plain Layout

        #desenha a terra
\end_layout

\begin_layout Plain Layout

        screen.blit(imagem_terra, (400-imagem_terra.get_width()/2.,300-imagem_terra.
get_height()/2.))
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

        # faz com que isto so aconteça outra vez daqui a 10 segs
\end_layout

\begin_layout Plain Layout

        ultimo_instante = este_instante       
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
5) Interface gráfico básico (Tkiter)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#coding=utf8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Tkiter é um biblioteca que nos permite fazer interfaces gráficos 
\end_layout

\begin_layout Plain Layout

import Tkinter
\end_layout

\begin_layout Plain Layout

import math   
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

#Rotinas
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Rotina a ser chamada quando se clicka no botão 'sair'
\end_layout

\begin_layout Plain Layout

def sair():
\end_layout

\begin_layout Plain Layout

    quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Rotina a ser chamada quando se clicka no botão 'calcula'
\end_layout

\begin_layout Plain Layout

def calcula():
\end_layout

\begin_layout Plain Layout

    # Diz ao python que queremos acesso a estas variáveis globais, que foram
 definidas fora desta função
\end_layout

\begin_layout Plain Layout

    global texto_vx, texto_h, texto_t, texto_distancia
\end_layout

\begin_layout Plain Layout

         # Obtem o texto que o utilizador escreveu no interface gráfico
 (texto_XX.get()) e converte para um numero real (float(XX))
\end_layout

\begin_layout Plain Layout

    vx = float(texto_vx.get())
\end_layout

\begin_layout Plain Layout

    h = float(texto_h.get())
\end_layout

\begin_layout Plain Layout

         # Faz os cálculos
\end_layout

\begin_layout Plain Layout

    t = math.sqrt(2*h/9.8)
\end_layout

\begin_layout Plain Layout

    distancia = vx*t          
\end_layout

\begin_layout Plain Layout

# Escreve o texto no interface gráfico.
 Notem que é preciso convertê-lo para uma cadeia de texto (string)
\end_layout

\begin_layout Plain Layout

    texto_t["text"] = str(t)
\end_layout

\begin_layout Plain Layout

    texto_distancia["text"] = str(distancia)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria a janela 
\end_layout

\begin_layout Plain Layout

janela = Tkinter.Tk() 
\end_layout

\begin_layout Plain Layout

# Muda o título 
\end_layout

\begin_layout Plain Layout

janela.title('Projectil')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Cria um contentor dos elementos do interface gráfico (invisível) 
\end_layout

\begin_layout Plain Layout

contentor = Tkinter.Frame(janela) # Adiciona o contentor  
\end_layout

\begin_layout Plain Layout

contentor.pack()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Cria os vários elementos do interface gráfico: texto simples (Label) ou
 caixas de edição de texto (Entry)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

titulo_vx = Tkinter.Label(contentor,text='vx (m/s)') titulo_vx.pack() 
\end_layout

\begin_layout Plain Layout

texto_vx = Tkinter.Entry(contentor,justify=Tkinter.RIGHT)
\end_layout

\begin_layout Plain Layout

texto_vx.insert(Tkinter.END, '1') #Escreve '1' na caixa de texto, inicialmente
 
\end_layout

\begin_layout Plain Layout

texto_vx.pack()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

titulo_h = Tkinter.Label(contentor,text='altura (m)') titulo_h.pack()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

texto_h = Tkinter.Entry(contentor,justify=Tkinter.RIGHT)
\end_layout

\begin_layout Plain Layout

texto_h.insert(Tkinter.END, '1')
\end_layout

\begin_layout Plain Layout

texto_h.pack()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

titulo_t= Tkinter.Label(contentor,text='t (s)') titulo_t.pack()
\end_layout

\begin_layout Plain Layout

texto_t= Tkinter.Label(contentor,text='-')
\end_layout

\begin_layout Plain Layout

texto_t.pack()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

titulo_distancia= Tkinter.Label(contentor,text='Distancia (m)')
\end_layout

\begin_layout Plain Layout

titulo_distancia.pack()
\end_layout

\begin_layout Plain Layout

texto_distancia = Tkinter.Label(contentor,text='-') texto_distancia.pack()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Adiciona dois botões, os quais chamam as funções calcula ou sair quando
 são clickados
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

botao1 = Tkinter.Button(contentor, text="Calcula", command=calcula)
\end_layout

\begin_layout Plain Layout

botao1.pack()
\end_layout

\begin_layout Plain Layout

botao2 = Tkinter.Button(contentor, text="Sair", command=sair) botao2.pack()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Calcula os resultados com os valores iniciais
\end_layout

\begin_layout Plain Layout

calcula()      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Corre o ciclo principal da janela.
 Isto quer dizer que a janela vai esperar  # que o utilizador interaja com
 ela para fazer alguma coisa.
 A execução vai ficar
\end_layout

\begin_layout Plain Layout

# parada nesta linha até que a janela seja fechada.
\end_layout

\begin_layout Plain Layout

janela.mainloop()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
